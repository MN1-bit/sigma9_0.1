# OHLCV 데이터 관리 전략 비교 리포트

**작성일:** 2025-12-19  
**목적:** 차트 데이터 저장 방식 비교 분석 및 엔터프라이즈급 시스템 사례 연구

---

## 1. 개요

OHLCV(Open, High, Low, Close, Volume) 데이터 관리에서 핵심 질문:

> **각 타임프레임별 데이터를 개별 수신/저장** vs **1분봉(1m), 일봉(1D) 기본 데이터만 저장 후 나머지는 합산 계산**

---

## 2. 방식 비교

### 2.1 방식 A: 각 타임프레임 개별 저장

| 항목 | 설명 |
|------|------|
| **방식** | 1m, 5m, 15m, 1h, 4h, 1D 각각 별도 API 호출 후 DB에 개별 테이블/컬럼으로 저장 |
| **저장 구조** | `ohlcv_1m`, `ohlcv_5m`, `ohlcv_15m` ... 각각의 테이블 |

**✅ 장점:**
- **빠른 쿼리 성능**: 원하는 타임프레임 즉시 조회, 집계 연산 불필요
- **구현 단순성**: 데이터 fetch 후 바로 저장/조회
- **데이터 정확도**: 거래소/데이터 제공자의 공식 집계값 사용

**❌ 단점:**
- **저장 공간 낭비**: 동일 데이터의 5~6배 중복 저장
- **API 비용 증가**: 타임프레임별 API 호출 필요 (Rate Limit, 과금)
- **동기화 복잡성**: 여러 테이블 간 데이터 정합성 유지 어려움

---

### 2.2 방식 B: 기본 데이터 + 온디맨드 합산 (권장)

| 항목 | 설명 |
|------|------|
| **방식** | 1분봉(1m) + 일봉(1D) 저장 → 5m, 15m, 1h, 4h는 1m 데이터에서 실시간 합산 |
| **저장 구조** | `ohlcv_1m`, `ohlcv_1d` 2개 테이블만 유지 |

**합산 로직:**
```
5분봉 = 1분봉 5개 합산
  - Open:  첫 번째 1분봉의 Open
  - High:  5개 캔들 중 최대 High
  - Low:   5개 캔들 중 최소 Low  
  - Close: 마지막 1분봉의 Close
  - Volume: 5개 캔들 Volume 합계
```

**✅ 장점:**
- **저장 효율성**: 1m 데이터 하나로 모든 분봉 생성 (70~80% 스토리지 절감)
- **데이터 일관성**: 단일 소스(Single Source of Truth)에서 파생
- **API 비용 절감**: 1m, 1D 두 종류만 fetch
- **유연성**: 3분봉, 7분봉 등 커스텀 타임프레임 즉시 생성 가능

**❌ 단점:**
- **연산 오버헤드**: 조회 시 집계 연산 필요 (초기 로딩 시 약간의 지연)
- **구현 복잡도**: 합산 로직 및 캐싱 전략 필요

---

## 3. 성능 비교 (실제 수치 분석)

### 3.1 스토리지 비용

| 타임프레임 | 일일 캔들 수 | 10년 데이터 (1종목) |
|-----------|-------------|-------------------|
| 1m | 390개 (6.5h × 60) | ~1.0M 레코드 |
| 5m | 78개 | ~200K 레코드 |
| 15m | 26개 | ~65K 레코드 |
| 1h | 7개 | ~18K 레코드 |
| 1D | 1개 | ~2.5K 레코드 |

**방식 A (모두 저장):** 약 1.3M 레코드/종목  
**방식 B (1m + 1D만):** 약 1.0M 레코드/종목 (**~23% 절감**)

> [!NOTE]
> 5,000종목 기준 10년 데이터: **방식 B가 약 1.5TB 스토리지 절감**

### 3.2 API 호출 비용 (Polygon.io 기준)

| 방식 | 일일 API 호출 | 월간 (5,000종목) |
|------|-------------|-----------------|
| 방식 A | 6회/종목 | 900,000회 |
| 방식 B | 2회/종목 | 300,000회 |

> **방식 B가 API 비용 약 66% 절감**

---

## 4. 엔터프라이즈 시스템 사례

### 4.1 TradingView

```
┌─────────────────────────────────────────────────────────┐
│                    TradingView 아키텍처                   │
├─────────────────────────────────────────────────────────┤
│  [Tick Data] → [1m OHLCV 저장] → [Continuous Aggregates] │
│                      ↓                                   │
│              Pre-computed: 5m, 15m, 1h, 1D              │
│                      ↓                                   │
│              CDN Cache + WebSocket Real-time            │
└─────────────────────────────────────────────────────────┘
```

**핵심 특징:**
- **Hybrid 방식 채택**: 1m 기본 저장 + 자주 사용 타임프레임 Pre-aggregate
- **TimescaleDB 활용**: Continuous Aggregates로 자동 증분 업데이트
- **CDN 캐싱**: 자주 조회되는 타임프레임은 미리 계산 후 캐싱

### 4.2 한국 HTS (키움, 삼성증권 등)

```
┌─────────────────────────────────────────────────────────┐
│                     HTS 아키텍처                          │
├─────────────────────────────────────────────────────────┤
│  [Tick 수신] → [1분봉 실시간 생성] → [DB 저장]             │
│                      ↓                                   │
│         사용자 요청 시 3m, 5m, 10m, 30m 실시간 합산        │
│                      ↓                                   │
│              일봉/주봉/월봉 별도 Pre-compute              │
└─────────────────────────────────────────────────────────┘
```

**핵심 특징:**
- **1분봉 기반 합산**: 분봉 데이터는 1분봉에서 실시간 계산
- **일봉 이상은 별도 저장**: 일봉, 주봉, 월봉은 Pre-computed
- **window_size 컬럼**: DB에 타임프레임 구분 필드 사용

### 4.3 Binance

- Tick 데이터 → 1분봉 기본 저장
- 각 타임프레임 API 엔드포인트는 서버에서 실시간 합산 제공
- 클라이언트는 원하는 타임프레임 API 호출 (서버가 합산 처리)

---

## 5. 권장 아키텍처 (Sigma9)

```
┌────────────────────────────────────────────────────────────┐
│                   Sigma9 권장 구조                           │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  [Polygon API] ──┬──→ [1m OHLCV] ──→ SQLite (ohlcv_1m)     │
│                  │                                          │
│                  └──→ [1D OHLCV] ──→ SQLite (ohlcv_daily)  │
│                                                             │
│  ─────────────────────────────────────────────────────────  │
│                                                             │
│  [Chart Request: 5m] → aggregate_from_1m(5) → Cache → UI   │
│  [Chart Request: 15m] → aggregate_from_1m(15) → Cache → UI │
│  [Chart Request: 1h] → aggregate_from_1m(60) → Cache → UI  │
│                                                             │
│  ─────────────────────────────────────────────────────────  │
│                                                             │
│  [Daily+] → ohlcv_daily 직접 조회 (Pre-stored)              │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

### 5.1 구현 제안

#### DB 스키마
```sql
-- 분봉 테이블 (1분봉만 저장)
CREATE TABLE ohlcv_1m (
    ticker TEXT,
    timestamp INTEGER,  -- Unix timestamp
    open REAL,
    high REAL, 
    low REAL,
    close REAL,
    volume INTEGER,
    PRIMARY KEY (ticker, timestamp)
);

-- 일봉 테이블
CREATE TABLE ohlcv_daily (
    ticker TEXT,
    date TEXT,  -- YYYY-MM-DD
    open REAL,
    high REAL,
    low REAL,
    close REAL,
    volume INTEGER,
    PRIMARY KEY (ticker, date)
);
```

#### 합산 유틸리티
```python
def aggregate_candles(candles_1m: List[dict], period: int) -> List[dict]:
    """1분봉 데이터를 N분봉으로 합산"""
    result = []
    for i in range(0, len(candles_1m), period):
        chunk = candles_1m[i:i+period]
        if not chunk:
            continue
        result.append({
            'time': chunk[0]['time'],
            'open': chunk[0]['open'],
            'high': max(c['high'] for c in chunk),
            'low': min(c['low'] for c in chunk),
            'close': chunk[-1]['close'],
            'volume': sum(c['volume'] for c in chunk)
        })
    return result
```

---

## 6. 결론 및 권장사항

| 기준 | 방식 A (개별 저장) | 방식 B (합산) | 권장 |
|-----|------------------|-------------|------|
| 스토리지 비용 | ❌ 높음 | ✅ 낮음 | B |
| API 비용 | ❌ 높음 | ✅ 낮음 | B |
| 쿼리 성능 | ✅ 빠름 | ⚠️ 연산 필요 | A (캐싱으로 보완) |
| 데이터 일관성 | ⚠️ 동기화 필요 | ✅ 단일 소스 | B |
| 구현 복잡도 | ✅ 단순 | ⚠️ 합산 로직 필요 | A |
| 유연성 | ❌ 고정 타임프레임 | ✅ 커스텀 가능 | B |

> [!IMPORTANT]
> **최종 권장: 방식 B (1m + 1D 저장 + 온디맨드 합산)**
> 
> TradingView, HTS 등 엔터프라이즈 시스템과 동일한 표준 아키텍처입니다.
> 캐싱 레이어를 추가하면 성능 이슈도 해결됩니다.

### 추가 최적화 옵션

1. **인메모리 캐시**: 최근 N일 1분봉 데이터를 메모리에 캐싱
2. **Pre-computed 캐시**: 자주 조회되는 5m, 15m은 SQLite 임시 테이블에 캐싱
3. **Lazy Loading**: 스크롤 시 필요한 구간만 합산

---

## 참고 자료

- TradingView Datafeed API Documentation
- TimescaleDB Continuous Aggregates
- Polygon.io Aggregates API
- 국내 HTS (키움증권, 삼성증권) 시스템 분석
