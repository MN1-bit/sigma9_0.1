# 전략 문서 융합에서 탄생한 상위 진리

> 4개 전략서(Anthropic, ChatGPT, Gemini, Perplexity)의 충돌과 수렴에서 도출된 메타 프레임워크
> 
> **QTS 패널**: Q(퀀트) · T(익스퍼트데이트레이더) · S(시스템설계/개발자)

---

## 핵심 명제: 유동성 우선성 원리 (Liquidity Primacy Thesis)

> **"개잡주 트레이딩의 본질은 '가격 예측'이 아니라, '실행 가능한 유동성 상태 전이'를 포착하는 것이다."**

4개 전략서를 관통하는 최상위 진리:

- **Gemini**: "Stock is Inventory" - 가치가 아닌 재고로서의 주식
- **Anthropic**: "유동성 불균형이 가격을 결정" - 펀더멘털 무관
- **Perplexity**: "수급 왜곡이 엣지의 원천" - 리스크/유동성 구조 선행
- **ChatGPT**: "마찰과 꼬리리스크가 EV를 망친다" - 실행 비용 중심

**융합된 결론**: 우리가 노리는 것은 **시장의 일시적 기능 부전 상태**다. 

### 핵심 패러다임 전환

| 기존 사고 | 새로운 사고 |
|-----------|-------------|
| "엣지 = 예측" | "엣지 = 필터링 + 손실 구조 설계" |
| "모델이 맞추는가?" | "틀렸을 때 비용 구조는?" |
| "언제 진입하나?" | "언제 진입하지 말아야 하나?" |

> [!NOTE]
> **💬 QTS 코멘트**
> 
> **Q**: 철학적으로는 동의하지만, "유동성 상태 전이"를 어떻게 정량화할 건가? 측정 불가능한 개념은 백테스트도 불가능하다. 최소한 스프레드 변화율, 호가 잔량 비율, 체결 속도 같은 **측정 가능한 프록시**를 명시해야 한다.
>
> **T**: 이론은 맞는데, 실전에선 이런 거 생각할 시간이 없어. 테이프가 "붙는다/안 붙는다"는 0.5초 안에 느껴져야 해. **체화된 직관**이 없으면 이 원리는 무용지물.
>
> **S**: "일시적 기능 부전"의 정의가 모호함. 시스템 구현 시 **이산 상태(Discrete State)**로 정의해야 함. 예: `NORMAL`, `VACUUM`, `SQUEEZE`, `COLLAPSE`.

---

## 1. 실행 레짐 이론 (Execution Regime Theory)

### 개념 정의

가격 레짐이 아니라 **실행 레짐**이 모든 판단의 선행 조건이다.

| 지표 | 개선 중 (Green) | 악화 중 (Red) |
|------|-----------------|---------------|
| **스프레드** | 축소 | 확대 |
| **체결 속도** | 가속 | 둔화 |
| **호가 잔량** | 채워짐 | 텅빔 |
| **테이프 방향** | 매수 우세 | 매도 우세 |

### 핵심 원칙

> **"동일한 차트 패턴이라도, 실행 레짐이 Green일 때만 '진짜'가 된다."**

- 패턴/뉴스/레벨 = **트리거 후보**
- 실행 레짐 Green = **트리거 확정 조건**
- 둘의 동시 정렬 = **진입 허가**

> [!NOTE]
> **💬 QTS 코멘트**
> 
> **Q**: 4개 지표의 **가중치**는? 동일 가중? 스프레드가 축소되는데 체결이 둔화되면 Green인가 Red인가? **복합 신호 해석 규칙**이 필요하다. 단순 AND 조건은 너무 엄격하고, OR은 너무 느슨하다.
>
> **T**: 호가 잔량보다 **호가 변화 속도**가 더 중요해. 잔량이 많아도 순식간에 사라지면 텅빈 거야. 스냅샷이 아니라 **델타**를 봐야 해.
>
> **S**: 이 4개 지표를 실시간으로 계산하려면 틱 데이터 스트림 필요. Level 2 전체 스냅샷은 초당 수십 MB. **메모리/지연 트레이드오프** 고려해서 샘플링 주기 정해야 함. 100ms? 500ms?

### 구현 아키텍처: 4계층 상태 인식

**해결 과제**: 익스퍼트가 0.5초 안에 느끼는 "그것"을 시스템에 이식

| 익스퍼트 직관 | 의미 |
|---------------|------|
| "붙는다" | 체결 가속 + 방향 일치 |
| "받아주고 있다" | 대량 체결에도 가격 유지 |
| "빠지고 있다" | 유동성 고갈 + 스프레드 확대 |

**설계 원칙**:
- **점수 ❌ → 상태 ✅**: 가중합이 아닌 이산 상태(Micro-State)
- **체결 기반**: 호가(스푸핑 취약) 대신 Effective Spread 사용

**4계층 구조**:
```
Layer 4: 매크로 상태 → Green/Yellow/Red
Layer 3: 마이크로 상태 → ABSORPTION, VACUUM, EXHAUSTION...
Layer 2: 파생 지표 → 가속도, 불균형, 흡수율
Layer 1: 원시 지표 → 체결속도, 스프레드, 체결방향
```

**Layer 1 원시 지표**:

| 지표 | 계산 | 단위 |
|------|------|------|
| `trade_volume` | 단위 시간당 체결량 | shares/sec |
| `bid_volume` / `ask_volume` | Bid/Ask 체결 수량 | shares |
| `effective_spread` | 2 × \|체결가 - 중간가\| | % |

**Layer 2 파생 지표**:

| 지표 | 계산 | 의미 |
|------|------|------|
| `tape_accel` | d(velocity)/dt | 체결 가속도 |
| `trade_imbalance` | (bid-ask)/total | 방향 불균형 (-1~+1) |
| `absorption_ratio` | large_trade_vol / price_impact | 흡수 효율 |

**Layer 3 마이크로 상태**:

| 상태 | 조건 | 의미 |
|------|------|------|
| **ABSORPTION** | large_trade + price_impact < 0.1% | 받아주고 있음 |
| **VACUUM** | tape_accel > +θ + ask_depth↓ | 유동성 고갈 |
| **DISTRIBUTION** | imbalance < -0.3 + price 정체 | 분배 중 |
| **EXHAUSTION** | tape_accel < -θ + spread↑ | 소진 |

**Layer 4 합성 로직**:
```
🟢 Green: (ABSORPTION OR VACUUM) AND NOT (DISTRIBUTION OR EXHAUSTION)
🟡 Yellow: DISTRIBUTION OR EXHAUSTION
🔴 Red: PANIC OR spread > critical
```

**구현 요점**: 샘플링 100-500ms, 히스테리시스 0.5-2초, CPU 0.01%

> [!NOTE]
> **💬 QTS 코멘트 (4계층 아키텍처)**
> 
> **Q**: 마이크로 상태별 **승률/기대값을 반드시 백테스트**해야 함. ABSORPTION 상태에서 진입 후 N초 가격 변화 분포가 실제로 유의한가? 직관적으로 맞아 보여도 데이터가 없으면 신뢰 불가.
>
> **T**: 4개 마이크로 상태는 내가 느끼는 것과 대체로 일치해. 근데 **HIDDEN_BUYER**는 잡기 어려워. 숨은 건 숨어있으니까. 오히려 "있다가 드러났을 때" 인지하는 게 현실적.
>
> **S**: `effective_spread` 사용은 좋은 결정. 호가 기반 스푸핑 문제 회피. 단, `absorption_ratio` 계산에 필요한 `refill` 속도는 Level 2 데이터 필요 → **완전한 체결 기반은 아님**. 트레이드오프 인지하고 가야 함.

---

## 2. Rotation 가속도 기반 상태 이론 (Acceleration-Based State Theory)

### 설계 철학

**기존 Phase 이론의 문제점**:
- Float 절대값 의존 → SEC 파일링 ≠ 실제 거래 가능 물량
- "3회", "5회" 같은 고정 임계값 → 종목/상황마다 다름

**새로운 접근**: 절대값 대신 **상대 변화(가속도)**에 의존

### 가속도 기반 상태 정의

```
Rotation Velocity = d(Rotation) / dt   // 1차 미분
Rotation Accel    = d(Velocity) / dt   // 2차 미분
```

| 상태 | 조건 | 의미 |
|------|------|------|
| **FUEL** | Accel > +threshold | 회전 가속 중, 연료 상태 |
| **TRANSITION** | \|Accel\| ≤ threshold | 중립, 방향 불명 |
| **FATIGUE** | Accel < -threshold (지속) | 회전 둔화, 피로 상태 |

### 상태 전이 규칙 (히스테리시스 적용)

```
FUEL → TRANSITION: Accel < +threshold
TRANSITION → FATIGUE: Accel < -threshold 가 N초 이상 지속
FATIGUE → TRANSITION: Accel > -threshold
TRANSITION → FUEL: Accel > +threshold
```

### 적용 범위 구분: 상태 vs 행동

> **S 의견 채택**: 상태 분류는 단독 조건, 행동 트리거는 AND 조건

| 용도 | 조건 | 행동 |
|------|------|------|
| **상태 분류** | Accel **단독** | 상태만 변경, 행동 없음 |
| **경고 발생** | Accel 둔화 **OR** 실행 레짐 악화 | 🟡 Yellow (진입 주의) |
| **강제 행동** | Accel 둔화 **AND** 실행 레짐 악화 | 🔴 Red (청산 트리거) |

**이 구조의 장점**:
1. 상태 분류는 민감하게 → 빠른 인지
2. 행동 트리거는 보수적으로 → 오탐 방지

### 노이즈 필터 전략 (백테스트 대상)

| 전략 | 설명 | 테스트 필요 |
|------|------|-------------|
| **EMA 스무딩** | Rotation에 EMA 적용 후 미분 | lookback window |
| **Threshold + Persistence** | Accel < -X 가 N초 이상 지속 | 지속 시간 |
| **AND 조건** | Accel + 실행 레짐 동시 악화 | 조합 효과 |

> [!IMPORTANT]
> **💬 QTS 코멘트 (업데이트)**
> 
> **Q**: Phase 삭제하고 가속도로 단일화한 결정 지지. Float 오차 문제 회피. **lookback window, 스무딩 방식, threshold 값**은 백테스트로 최적화 필수. 노이즈 필터 전략 간 A/B 테스트 권장.
>
> **T**: 숫자("3회, 5회")에서 벗어난 건 좋아. 하지만 결국 **"느낌"**은 가속도 꺾임에서 온다는 거니까 맞아. 관건은 시스템이 내 직관보다 빨리 잡아주느냐.
>
> **S**: 계산 비용 무시 가능 (O(1)). 상태/행동 분리 구조로 FSM 구현 시 **상태 로그**와 **행동 로그** 별도 관리 가능. 섹션 6 붕괴 예고 시스템과 자연스럽게 통합됨.

---

## 3. 시간 통합 원리: Half-Life 중심 설계

### 기존 문제

문서 내 "시간 개념"이 파편화되어 있음:
- 시간대별 Prior (09:30-10:30 vs 11:30-14:00)
- ARMED 상태 Timeout
- 촉매별 유동성 수명

### 새로운 통합: Half-Life를 공통 시간 단위로

> **"촉매 분류가 곧 리스크/시간 정책으로 직결"**

| 촉매 유형 | Half-Life | ARMED Timeout | 트레일링 강도 | 진입 허용 |
|-----------|-----------|---------------|---------------|-----------|
| FDA 승인 | 수 시간 | 30분 | 느슨 | ✅ |
| 계약 발표 | 1-3시간 | 15분 | 중간 | ✅ |
| 테마 편승 | 30분-1시간 | 5분 | 공격적 | ⚠️ 축소 |
| 원인 불명 | 수 분 | 1분 | 극공격 | ❌ 봉쇄 |

**공식화**:
```
ARMED_Timeout = min(기본값, half_life × 0.3)
Trailing_Strength = f(half_life)  // 길수록 느슨
Entry_Size = base_size × half_life_score
```

### 시간대별 임계값 스케줄링 (기존 유지)

| 시간대 | 특성 | 스프레드 허용 | 체결 속도 요구 |
|--------|------|---------------|----------------|
| **09:30-10:30** | 최대 유동성 | 0.5% | 표준 |
| **11:30-14:00** | Dead Zone | 0.2% | 2배 |
| **15:00-16:00** | Power Hour | 0.3% | 1.5배 |

> [!IMPORTANT]
> **💬 QTS 코멘트 (신규)**
> 
> **Q**: Half-Life 통합 아이디어는 우아하다. 하지만 **Half-Life 추정의 정확도**가 전체 시스템 성능을 좌우함. 촉매 유형별 Half-Life의 **경험적 분포**를 먼저 수집해야 함. 분산이 크면 예측력 없음.
>
> **T**: 뉴스 자체보다 **시장 반응**이 더 중요해. 같은 FDA 승인이라도 장전에 터지냐, 이미 기대 반영됐냐에 따라 천지차이. Half-Life는 **초기 반응 강도**로 동적 조정해야 함.
>
> **S**: Half-Life 기반 파라미터화는 구현 복잡도를 **크게 줄여줌**. 하나의 입력(촉매 유형)으로 여러 파라미터가 자동 결정되므로. NLP 룰 기반으로 촉매 분류 시작 → 점진적 ML 개선 경로.

---

## 4. 2단계 트리거 시스템 (Two-Stage Trigger)

### 인간/시스템 역할 분리

| 단계 | 역할 | 담당 | 시간 |
|------|------|------|------|
| **Stage 1: 구조** | "준비 완료" 판정 | 시스템 | 수 초 전 |
| **Stage 2: 테이프** | "지금!" 실행 | 인간 | 0.5초 내 |

```
[구조 조건 충족] → ARMED 상태 진입 → 대기 (Timeout 적용)
[테이프 트리거 발동] → 즉시 실행
```

### ARMED 상태 관리

```
상태 머신:
IDLE → [구조 충족] → ARMED → [테이프 트리거] → TRIGGERED → IN_POSITION
                         ↓ [Timeout]
                       IDLE (기회 소멸)
```

**Timeout 규칙**:
- 기본값: 15분
- Half-Life 연동: `min(15분, half_life × 0.3)`
- 실행 레짐 Red 전환 시: 즉시 IDLE 복귀

> [!NOTE]
> **💬 QTS 코멘트**
> 
> **Q**: 이 구조는 **백테스트가 극히 어렵다**. Stage 2의 "테이프 트리거"는 인간 판단이 개입하므로 재현 불가능. 자동화할 거면 테이프 트리거 조건도 정량화해야 하고, 인간에게 맡길 거면 백테스트 결과를 믿으면 안 됨.
>
> **T**: ARMED 상태에서 기다리는 동안 **타이밍 놓치는 경우**가 많아. 구조 완벽한데 테이프가 안 터져서 패스했다가, 직후 폭등하는 거 수없이 봤어. Timeout 설정이 핵심인데, Half-Life 연동은 좋은 아이디어.
>
> **S**: ARMED 상태 관리는 **FSM 패턴**으로 구현. 상태 전이 로그 필수. 각 전이에 타임스탬프와 조건 기록 → 나중에 **"왜 진입 안 했는가"** 복기 가능.

---

## 5. 공격성 동적 조절 (Regime-Based Aggression)

### 융합 해법

> **"공격성은 성격이 아니라 시장 레짐의 함수"**

| 레짐 | 지표 | 공격성 배수 |
|------|------|-------------|
| **Bull** | 데이게이너 다수, 평균 갭률 大 | 1.5x |
| **Neutral** | 혼조 | 1.0x |
| **Chop** | 휩소 빈발 | 0.5x |
| **Bear** | 데이루저 우세 | 0.3x |

### 미해결 충돌: 정책 분리로 해결

문서 간 충돌(Float 임계값, 리버설 허용, 오버나잇 등)은 **전략 목표 함수**가 다를 때 발생.

**해결책: 정책(Policy) 분리**

| 정책 | Float 임계 | 리버설 | 오버나잇 | 대상 |
|------|------------|--------|----------|------|
| **Aggressive** | 20M | 허용 | 선택적 | 고변동 선호 |
| **Standard** | 10M | 금지 | 금지 | 기본 |
| **Conservative** | 5M | 금지 | 금지 | 안정 선호 |

> [!WARNING]
> **💬 QTS 코멘트**
> 
> **Q**: 레짐 분류 자체가 **후행 지표**. "오늘 데이게이너 많네"를 알 때는 이미 장 중반. **장 시작 전 예측적 분류** 필요. 장전 선물, 갭 분포, 전일 패턴, VIX 등 활용.
>
> **T**: 레짐 바뀌는 속도가 생각보다 빨라. 오전 Bull → 점심 Chop → 오후 Bull. **일중 레짐 전환 감지** 필수.
>
> **S**: 정책 분리 아이디어 좋음. 시스템 설계 시 **Policy 객체**로 추상화. 사용자가 세션 시작 시 정책 선택하거나, 레짐 분류기가 자동 전환. 런타임 정책 교체 지원 필요.

---

## 6. 붕괴 예고 시스템 (Collapse Warning) — 강화

### 기존 문제

단일 지표(Rotation Accel)만으로는 오경보 빈발

### 강화된 경보 조건: 원인 + 증상 동시 감지

```
[원인] Rotation Acceleration < 0 (피로)
  AND
[증상] Spread 확대 OR 체결 둔화 (실행 레짐 악화)
  →
⚠️ "분배/덤프 임박" 경보
```

**이 구조의 장점**:
1. Float 오차 완화: 가속도 = 상대 변화, 오차에 덜 민감
2. 실행 레짐 = 시장에서 직접 관측, 추정 불필요
3. AND 조건으로 오경보 감소

### 경보 후 행동

| 경보 레벨 | 조건 | 행동 |
|-----------|------|------|
| ⚠️ Yellow | 원인 OR 증상 | 신규 진입 금지 |
| 🔴 Red | 원인 AND 증상 | 즉시 청산 트리거 |

> [!CAUTION]
> **💬 QTS 코멘트 (보강)**
> 
> **Q**: 원인+증상 AND 조건으로 Precision 개선 예상. 하지만 **Recall 하락** 가능성도. 진짜 붕괴인데 경보 안 울리는 케이스 분석 필요. Precision-Recall 트레이드오프 백테스트 필수.
>
> **T**: 경보 울려도 **이미 스프레드 벌어져 있으면 못 나가**. 경보 → 자동 청산 연결 필수. 수동 청산은 늦음.
>
> **S**: 경보 시스템은 **이벤트 기반 아키텍처**로. Pub/Sub 패턴 사용. 경보 발생 → 청산 모듈 구독 → 즉시 반응. 지연 목표: <100ms. 두 조건(Rotation Accel, 실행 레짐)을 별도 스트림으로 계산 후 **CEP(Complex Event Processing)** 엔진에서 합성.

---

## 7. 반박 게이트 (Adversarial Gate) — 운영 내장

### 개념: 적대적 협업의 시스템화

Entry 직전에 **"이 진입을 하지 말아야 할 이유"**를 강제로 찾는 반박 체크.

### 체크리스트 (자동화 대상)

| 조건 | 검사 내용 | 위반 시 |
|------|-----------|---------|
| 시간대 | Dead Zone (11:30-14:00)? | 🔴 봉쇄 |
| Rotation 위상 | Phase 3 (5회+)? | 🟡 경고 |
| Half-Life | 촉매 없음/원인 불명? | 🔴 봉쇄 |
| 실행 레짐 | Red 상태? | 🔴 봉쇄 |
| 일일 손실 | 한도의 80% 도달? | 🟡 사이즈 50% |
| 붕괴 경보 | Yellow 이상? | 🟡 경고 |

### UI 표현

```
신호등 시스템:
🟢 All Clear → 표준 진입
🟡 Warning  → 사이즈 축소 or 재검토
🔴 Blocked  → 진입 불가 (시스템 차단)
```

**효과**: 정확도 향상보다 **실수 방지(운영 안정성)** 측면에서 큰 효과.

> [!NOTE]
> **💬 QTS 코멘트 (신규)**
> 
> **Q**: 반박 게이트가 **부정 편향(Negativity Bias)** 강화할 위험. 모든 거래 막으면 수익도 0. 게이트 통과 vs 차단 거래의 **사후 성과 비교** 추적해서 게이트 효용 검증 필요.
>
> **T**: 실전에선 이거 다 체크할 시간 없어. **3초 안에 판단**해야 할 때가 많아. 체크리스트는 복기용으로는 좋지만, 실시간에는 **신호등 하나만** 보여줘야 함.
>
> **S**: 6개 조건 실시간 계산해서 UI에 신호등으로 표시. 인간은 신호등만 보고 판단. 연산은 시스템이 담당. 각 조건의 계산은 독립적이므로 **병렬 처리** 가능.

---

## 8. QCA 활용: 룰 최소화기

### 기존 문제

QCA로 성공/실패 경로를 정리했지만, 그대로 룰로 박으면 복잡도 폭발.

### 새로운 역할 정의

QCA를 **"룰 생성기"**가 아니라 **"룰 최소화기"**로 활용:

| 역할 | 설명 |
|------|------|
| **중복 조건 제거** | 여러 경로에 공통인 조건 → 상위 필터로 승격 |
| **필요조건만 남기기** | 모든 성공 경로에 공통 → 필수 조건 |
| **충분조건은 분리** | 특정 경로에만 해당 → 플레이북별 분리 |

**예시**:
```
모든 성공 경로 분석 결과:
  - 공통 필요조건: RVOL ≥ 3, Catalyst 존재, VWAP 상방
  - 경로별 충분조건:
    - 경로 A: Float < 10M + Short Interest > 20%
    - 경로 B: 체결 가속 + 스프레드 축소
```

**효과**: 시스템이 커져도 **규칙 비대화 방지**.

> [!NOTE]
> **💬 QTS 코멘트 (신규)**
> 
> **Q**: QCA를 최소화기로 쓰는 발상은 좋음. **필요조건은 AND 게이트, 충분조건은 OR 게이트**로 구현. 조건 추가/제거가 전체에 미치는 영향을 **민감도 분석**으로 추적해야 함.
>
> **T**: 조건이 적을수록 좋아. 복잡한 룰은 실전에서 안 지켜져. **3개 이하의 핵심 조건**만 남기는 게 현실적.
>
> **S**: 필요조건은 **입구 필터(Stage 1)**, 충분조건은 **플레이북별 모듈**로 분리 구현. 새 플레이북 추가 시 필요조건은 건드리지 않고 충분조건만 추가하는 **확장 가능한 아키텍처**.

---

## 9. 엣지의 계층 구조 (Edge Hierarchy)

| 계층 | 유형 | 예시 |
|------|------|------|
| **1차 엣지** | 실행/적응 | 속도, 비용, 심리, 적응 |
| **2차 엣지** | 전략/패턴 | VWAP Reclaim, 플레이북 |

> **"전략서는 '무엇을 할지'를 알려주지만, 진짜 승패는 '얼마나 잘 실행하는가'에서 갈린다."**

> [!IMPORTANT]
> **💬 QTS 코멘트**
> 
> **Q**: 1차 엣지 중 **"적응 속도"**가 가장 측정하기 어렵다. 이걸 어떻게 시스템화? 결국 **메타 전략(전략의 전략)**이 필요한데, 그건 또 다른 복잡도를 추가.
>
> **T**: 실행 속도는 결국 **인프라 싸움**이야. 같은 전략이라도 1초 빠르면 이기고 1초 느리면 져. DAS Trader 쓰냐 웹 브로커 쓰냐 차이가 전략 차이보다 클 수 있어.
>
> **S**: 실행 속도 최적화는 코로케이션 영역. 개인 수준에서는 한계. 차라리 **경쟁이 덜한 틈새**를 찾는 게 현실적.

---

## 10. 손실 구조 설계 (Loss Structure Engineering)

> **"예측도 필터링도 아닌, '틀렸을 때의 비용 구조 설계'가 진짜 엣지"**

### 핵심 원칙

- 손실 시나리오의 최대치가 통제되어 있으면 장기 생존
- 모델이 **"맞추는가"**가 아니라 **"틀렸을 때 비용"**이 핵심

### 자동 손절 필수

```
손절 = 심리적으로 가장 어려운 부분
      → 규칙 있어도 안 지켜짐
      → 자동 손절 아니면 무조건 밀림
```

> [!NOTE]
> **💬 QTS 코멘트**
> 
> **Q**: **Half-Kelly** 또는 **1/4 Kelly** 사용 권장. Full Kelly는 파산 확률 높음. 불확실성 고려한 보수적 사이징.
>
> **T**: "다음엔 지켜야지"는 100번 해도 안 됨. **자동 손절 시스템** 필수.
>
> **S**: **자동 손절 시스템**은 브로커 API 의존. API 지연, 부분 체결, 슬리피지 모두 고려한 **손절 시뮬레이션** 필요. 백테스트에서 이상적 손절 가정하면 실전과 괴리 큼.

---

## 최종 통합: Tradability-Adjusted EV

```
Tradability-Adjusted EV =
    (시간대 prior)
  × (촉매 half-life)
  × (레벨 정렬도)
  × (실행 레짐 품질)
  × (Rotation 위상 점수)
  − (꼬리리스크: 홀트/갭/희석/오버나잇)
```

> [!IMPORTANT]
> **💬 QTS 최종 코멘트**
> 
> **Q**: 개념적 프레임워크로는 훌륭. 정량 모델로 쓰려면 각 항의 **스케일링과 결합 방식** 정의 필요. 곱셈? 가중합? 범위는 0-1? 이걸 정의 안 하면 시스템 구현 불가.
>
> **T**: 공식이 복잡하면 실전에서 못 써. "테이프 붙나? 유동성 있나? 손절 어디냐?" 세 가지로 귀결. 화면엔 **Go/No-Go 하나만** 보여줘.
>
> **S**: 문서 전체 구현에 **최소 6개월 풀타임**. 우선순위 정해야 함.

---

## 다음 스텝: 로그 체계 선행

> **"Stage 1(선별) ↔ Stage 2(진입) 분리 + Moderators의 '효과 반전 지점'을 학습하는 로그 체계를 먼저 깔면, 이후 어떤 규칙을 추가해도 '왜 추가했는지/언제 망가지는지'가 추적 가능한 시스템이 된다."**

### 로그 필수 항목

| 시점 | 기록 항목 |
|------|-----------|
| Stage 1 통과 | 모든 필터 조건 값, 타임스탬프 |
| ARMED 진입 | 촉매 유형, Half-Life 추정, Timeout |
| ARMED 종료 | 종료 사유 (Timeout/Trigger/Red 전환) |
| Entry | 실행 레짐 스냅샷, Stage 2 트리거 조건 |
| Exit | 청산 사유, P&L, 붕괴 경보 여부 |

**목적**: 반전 지점 학습 데이터 축적

---

## 시스템 구현 우선순위 (수정)

| 모듈 | 역할 | 우선순위 |
|------|------|----------|
| **로그 체계** | 모든 상태 전이 기록 | 🔴 P0 |
| **실행 레짐 모니터** | 스프레드/체결/호가 실시간 | 🔴 P0 |
| **자동 손절 시스템** | 브로커 API 연동 | 🔴 P0 |
| **반박 게이트 UI** | 신호등 시각화 | 🟡 P1 |
| **시간대 스케줄러** | 임계값 자동 조절 | 🟡 P1 |
| **Stage 1 스캐너** | Float, RVOL, Catalyst | 🟡 P1 |
| **붕괴 경보 시스템** | 원인+증상 AND 로직 | 🟢 P2 |
| **Rotation 위상 분류기** | 가속도 계산 | 🟢 P2 |
| **레짐 분류기** | 공격성 배수 | 🟢 P2 |
| **Half-Life 추정기** | 촉매 분류 → 시간 정책 | 🔵 P3 |
| **QCA 기반 룰 최적화** | 조건 최소화 | 🔵 P3 |

---

*통합일: 2026-01-12*
*QTS 패널 코멘트 추가: 2026-01-12*
*사용자 리뷰 반영 융합: 2026-01-12*
