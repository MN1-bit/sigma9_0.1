# 최대 사이징 로직 설계: 다자 토론

> **문서 목적**: max02.md(미니멀 접근)와 maximum_per_trade01.md(구조적 접근)를 기반으로, 최대 사이징 로직의 최종 설계를 도출하기 위한 다자 토론 기록
> **작성일**: 2026-01-14

---

## 등장인물

| 코드명 | 역할 | 성향 |
|--------|------|------|
| **🎯 스캘퍼** | 단타 고수 | 감각적, 직관적 해석 강함. 10년 이상 실전 경험. "숫자보다 테이프가 말해준다" |
| **📊 퀀트** | 퀀트 애널리스트 | 수학적, 통계적 접근. "검증 안 된 건 믿지 않는다" |
| **🏦 기관** | 기관 트레이더 | 금융공학적, 리스크 관리 중심. "실행 비용이 알파를 잡아먹는다" |
| **🔧 시스템** | 시스템 개발자 | 구현 관점, 연산 효율 중시. "실시간에서 돌아가야 한다" |
| **⚖️ 심판** | 토론 진행자 | 논리 통솔, 합의점 도출. "본질에 집중하자" |

---

## 토론 기록

---

### [01] ⚖️ 심판

오늘 주제는 **"최대 사이징 로직"**입니다. 두 문서가 있습니다:

1. **max02**: "본질만 남기자" - EMA 하나 + 스프레드로 최소 연산
2. **maximum_per_trade01**: "구조적 접근" - 상태머신, 게이트, 모더레이터 전부 활용

두 접근법의 장단점을 논의하고, **Rheograph 엔진에 실제로 구현할 최종 로직**을 합의해 봅시다.

첫 질문: **"노임팩트(No-Impact)"를 어떻게 정의해야 할까요?**

---

### [02] 🎯 스캘퍼

숫자로 정의하기 전에, **경험적으로** 말하자면요.

노임팩트는 **"내가 들어가도 테이프가 안 바뀌는 것"**입니다.
- 내 주문이 프린트되기 전후로 bid/ask 움직임이 없어야 함
- 체결 직후 역방향 테이프가 안 터져야 함

숫자로 환산하면? **스프레드 1~2틱 이내**에서 체결되면 노임팩트라고 봅니다.

---

### [03] 📊 퀀트

스캘퍼님 말씀은 직관적이지만, **정량화가 안 됩니다**.

학술적으로 가장 검증된 건 **Square-root law**입니다:

```
Impact ≈ κ × √(Q/V)
```

여기서:
- Q = 내 주문 크기 (달러)
- V = 시장 거래량 (달러)
- κ = 마찰 계수 (종목별, 시간대별 다름)

max02 문서가 이걸 정확히 쓰고 있습니다. **수학적으로 가장 깔끔한 정의**입니다.

---

### [04] 🏦 기관

둘 다 맞는 말인데, **실무에서는 다릅니다**.

우리(기관)는 노임팩트를 **"참여율(Participation Rate)"**로 정의합니다:
- 내 체결량 / 시장 체결량 ≤ π (예: 5~10%)

왜냐면:
1. 실시간으로 측정 가능
2. 규제 보고에도 쓰임
3. 알고 실행(TWAP, VWAP)의 기본 단위임

maximum_per_trade01 문서가 이 접근법을 씁니다.

---

### [05] 🔧 시스템

구현 관점에서 정리하면:

| 정의 | 입력 필요 | 연산량 |
|------|-----------|--------|
| Square-root (max02) | L(EMA), spread | 최소 |
| 참여율 (01 문서) | V(Δt), π, 상태 다수 | 중간 |
| Depth 기반 (L2) | 호가창 전체 | 최대 |

**실시간 틱 처리에서는 연산량이 곧 지연**입니다.
max02 방식이 구현에 가장 유리합니다.

---

### [06] ⚖️ 심판

정리하면 3가지 정의가 있네요:
1. **직관적**: 테이프가 안 바뀌면 노임팩트
2. **수학적**: Impact ≤ B_bps (예산 bps 이하)
3. **실무적**: 참여율 ≤ π

질문: **이 세 가지가 결국 같은 것을 다르게 표현한 건가요?**

---

### [07] 📊 퀀트

**네, 수학적으로 동치입니다.**

Square-root law를 뒤집으면:
```
Q_max = V × (B_bps / κ)²
```

참여율로 표현하면:
```
Q_max = π × V
```

두 식을 비교하면:
```
π = (B_bps / κ)²
```

즉, **κ와 B_bps를 정하면 π가 자동으로 결정**됩니다.
max02가 더 근본적인 공식이고, 참여율은 그걸 단순화한 버전입니다.

---

### [08] 🎯 스캘퍼

수학은 맞는데, **실전에서 κ를 어떻게 알죠?**

제가 보기엔:
- 종목마다 다름
- 시간대마다 다름 (오프닝 vs 데드존)
- 뉴스 떴을 때 급변함

κ를 "스프레드로 근사"한다는 max02 방식... **너무 단순한 거 아닌가요?**

---

### [09] 🏦 기관

스캘퍼님 말씀에 동의합니다.

우리는 κ를 **실시간으로 추정하지 않습니다**.
대신 **사후적으로 캘리브레이션**합니다:

1. 실제 슬리피지 로그 수집
2. κ_obs = slippage / √(Q/V) 계산
3. 70~90 퍼센타일로 κ 업데이트

처음엔 보수적으로 잡고, 데이터가 쌓이면 조정합니다.
max02 문서의 8번 항목이 정확히 이걸 말합니다.

---

### [10] 🔧 시스템

그러면 **구현 순서**가 명확해지네요:

**Phase 1 (MVP)**: 
- κ = 고정값 (예: 100 bps)
- 또는 κ = k_spr × spread_bps

**Phase 2 (캘리브레이션)**:
- 슬리피지 로그 기록
- 주 1회 κ 업데이트된 config 반영

Phase 1만으로도 **충분히 보수적인 사이징**이 나옵니다.

---

### [11] ⚖️ 심판

κ 추정 문제는 해결된 것 같습니다.
다음 질문: **진입(Entry)과 청산(Exit) 중 어느 쪽이 사이징의 병목인가요?**

---

### [12] 🎯 스캘퍼

**100% 청산입니다.**

들어갈 때는 시간과 가격을 고를 수 있어요.
근데 붕괴가 오면? **내가 나가고 싶을 때 남들도 나가고 싶어요.**

- 스프레드 벌어짐
- 체결량 급감 (역설적으로)
- 내가 시장 유동성의 대부분을 차지하게 됨

**Exit-first**가 당연합니다.

---

### [13] 🏦 기관

완전 동의입니다.

기관에서는 이걸 **"Liquidation Horizon"**이라고 합니다.
- 포지션 사이즈는 **"n일 내 청산 가능 물량"**으로 제한

개잡주(소형주)는 이게 더 극단적이죠.
maximum_per_trade01 문서의 **panic_discount** 개념이 이걸 반영합니다.

---

### [14] 📊 퀀트

수학적으로도:

```
Q_in = V_in × (B_in / κ)²
Q_out = V_out × (B_out / κ)² × panic_discount
Q_max = min(Q_in, Q_out)
```

여기서 **panic_discount < 1** 이고, **B_out ≤ B_in** (청산은 더 빡빡)이므로,
거의 항상 **Q_out < Q_in**입니다.

Exit가 병목인 건 수학적으로도 자명합니다.

---

### [15] 🔧 시스템

그러면 **V_out을 어떻게 추정하죠?**

max02는:
```
V_out = L × τ_out × panic_discount
```

maximum_per_trade01은:
```
v_panic = v × panic_discount
Q_out = π_out × v_panic × Δt_out
```

결국 같은 구조인데, **panic_discount 값을 얼마로 잡느냐**가 관건입니다.

---

### [16] 🎯 스캘퍼

panic_discount는 **종목 특성**에 따라 달라야 합니다:

- 대형주 (SPY, AAPL): 0.7~0.9 (붕괴해도 유동성 있음)
- 중형주 ($1B~10B): 0.5~0.7
- 소형주 ($100M~1B): 0.3~0.5
- 마이크로캡 (<$100M): 0.1~0.3 (사실상 막힘)

제 경험상 **0.3~0.5**로 시작하면 대부분 안전합니다.

---

### [17] 🏦 기관

우리도 비슷하게 씁니다.

추가로 **시장 상태**에 따른 보정도 합니다:

| 상태 | discount 배수 |
|------|--------------|
| 🟢 정상 | ×1.0 |
| 🟡 경고 | ×0.6 |
| 🔴 붕괴 | ×0.3 |

maximum_per_trade01의 **Moderator 곱셈 보정**이 이거죠.

---

### [18] ⚖️ 심판

panic_discount는 합의된 듯합니다: **0.3~0.7, 상태에 따라 동적**.

다음 질문: **max02는 "상태(State)"를 안 씁니다. 이게 문제 아닌가요?**

---

### [19] 📊 퀀트

max02의 철학은 **"상태는 결국 스프레드와 체결량에 반영된다"**입니다.

- 🔴 붕괴 → 스프레드 급등 → κ 증가 → Q_max 자동 감소
- 체결량 급감 → L 하락 → V 감소 → Q_max 자동 감소

**암묵적 상태 반영**이라고 볼 수 있습니다.

---

### [20] 🎯 스캘퍼

**그게 안 되는 경우가 있어요.**

"조용한 붕괴"가 있습니다:
- 스프레드는 그대로인데
- 테이프에 대형 셀러가 슬금슬금 나타남
- 갑자기 클리프 다이브

스프레드만 보면 **"이상 없음"**인데, 실제론 **붕괴 직전**이에요.

---

### [21] 🏦 기관

그래서 **Trade Imbalance** 같은 파생 지표가 필요합니다.

maximum_per_trade01의 Layer 2:
- tape_accel
- trade_imbalance
- absorption_ratio

이게 "조용한 붕괴"를 잡아냅니다.
max02는 이걸 빠뜨린 거죠.

---

### [22] 🔧 시스템

잠깐요. max02의 목표는 **"최소 연산"**입니다.

Trade Imbalance를 계산하려면:
- 매 틱마다 buy/sell 방향 판단 (Tick Rule 또는 Quote Rule)
- 롤링 윈도우 합계
- 비율 계산

이건 **EMA 한 줄보다 10배 이상 연산**입니다.

---

### [23] ⚖️ 심판

트레이드오프가 명확하네요:

| 접근 | 정확도 | 연산량 |
|------|--------|--------|
| max02 (스프레드+EMA) | 70~80% | 최소 |
| +Imbalance | 85~90% | 중간 |
| +Depth(L2) | 95%+ | 최대 |

**MVP에서 어디까지 넣을지**가 핵심입니다.

---

### [24] 📊 퀀트

제 의견: **MVP는 max02로 시작**하되,

**"조용한 붕괴" 감지용 하드 게이트 1개**만 추가:

```python
if spread_bps > spread_hard_max:
    Q_max = 0  # 봉쇄
```

max02에 이미 있습니다. 이게 **최소 비용으로 최악의 케이스를 막는 방법**입니다.

---

### [25] 🎯 스캘퍼

스프레드 게이트만으론 부족해요.

**"테이프 정지"** 케이스가 있습니다:
- 스프레드 정상
- 근데 체결이 안 됨 (L → 0)

이것도 게이트로 잡아야 합니다:
```python
if L < L_min:
    Q_max = 0
```

---

### [26] 🔧 시스템

그럼 **하드 게이트 2개**:

1. `spread_bps > spread_hard_max` → Q=0
2. `L < L_min` → Q=0

연산량은 거의 안 늘어납니다.
이거면 **"조용한 붕괴"의 90%**는 잡힙니다.

---

### [27] 🏦 기관

추가로 **Float 캡**도 필수입니다.

아무리 유동성이 좋아도, **Float의 0.5% 이상을 먹으면**:
- 내가 시장의 일부가 됨
- 청산 시 내가 가격을 결정하게 됨

```python
Q_float_cap = φ × Float
Q_max = min(Q_max, Q_float_cap)
```

---

### [28] ⚖️ 심판

좋습니다. 현재까지 합의된 **MVP 로직**:

```
1. spread_bps 계산
2. L 업데이트 (EMA)
3. GATE: spread > max → 0
4. GATE: L < min → 0
5. κ = max(κ_floor, k_spr × spread)
6. V_in = L × τ_in
7. V_out = L × τ_out × panic_discount
8. Q_in = V_in × (B_in/κ)²
9. Q_out = V_out × (B_out/κ)²
10. Q_max = min(Q_in, Q_out, Q_float_cap)
```

반론 있으신가요?

---

### [29] 🎯 스캘퍼

**시간대(Time-of-Day) 보정**이 빠졌습니다.

- 오프닝 (9:30-10:00): 유동성 폭발 → ×1.3
- 데드존 (11:30-14:00): 유동성 말라붙음 → ×0.5 또는 봉쇄
- 클로즈 (15:30-16:00): 다시 활발 → ×1.2

이건 **하드코딩해도 효과 큽니다**.

---

### [30] 📊 퀀트

시간대 보정은 **π나 panic_discount에 곱하면 됩니다**:

```python
ToD_mult = get_time_of_day_multiplier()
Q_in *= ToD_mult
Q_out *= ToD_mult
```

연산량 추가: 상수 lookup 1회. 무시 가능.

---

### [31] 🏦 기관

시간대 보정 값은 우리 데이터로 제안합니다:

| 시간대 | 코드 | 배수 |
|--------|------|------|
| Pre-Market | PRE | 0.3 |
| Opening | OPN | 1.3 |
| Mid-Morning | MID1 | 1.0 |
| Dead Zone | DEAD | 0.5 |
| Mid-Afternoon | MID2 | 0.8 |
| Close | CLO | 1.2 |
| After-Hours | AH | 0.2 |

---

### [32] 🔧 시스템

구현:

```python
TOD_MULT = {
    (9, 30, 10, 0): 1.3,   # OPN
    (10, 0, 11, 30): 1.0,  # MID1
    (11, 30, 14, 0): 0.5,  # DEAD
    (14, 0, 15, 30): 0.8,  # MID2
    (15, 30, 16, 0): 1.2,  # CLO
}
```

config로 빼면 튜닝도 쉽습니다.

---

### [33] ⚖️ 심판

시간대 보정 추가 합의.

다음: **τ_in과 τ_out(실행 시간창)을 어떻게 정할까요?**

max02는 고정값 (2~8초, 1~4초)을 제안하고,
maximum_per_trade01은 ARMED_Timeout에서 파생하자고 합니다.

---

### [34] 🎯 스캘퍼

**고정값이 낫습니다.**

- 진입은 **2~5초 안에 끝나야** 함 (그 이상은 이미 늦음)
- 청산은 **1~3초 안에** (패닉에서 10초는 영원함)

Timeout에서 파생하면 너무 길어질 수 있어요.
Half-Life가 30분이면 Δt_in도 30초? 그건 너무 느려요.

---

### [35] 📊 퀀트

maximum_per_trade01의 공식:
```
Δt_in = clamp(2s, 0.02 × ARMED_Timeout, 20s)
```

ARMED_Timeout이 30분(1800초)이면:
```
Δt_in = clamp(2, 0.02 × 1800, 20) = clamp(2, 36, 20) = 20초
```

20초는 여전히 길다는 의견에 동의합니다.

**상한을 8초로 낮추면**:
```
Δt_in = clamp(2s, 0.02 × Timeout, 8s)
```

---

### [36] 🏦 기관

우리 실행 알고에서는 **Price Urgency**에 따라 τ를 동적으로 씁니다:

- 급한 진입 (모멘텀 강함): 2~3초
- 보통: 5~8초
- 여유로움 (Range 내 진입): 10~15초

근데 **개잡주 단타**에서는 거의 항상 "급함"이니까,
**τ_in = 3~5초, τ_out = 1~3초**가 맞습니다.

---

### [37] 🔧 시스템

그러면 **단순화**:

```python
TAU_IN = 4  # 초
TAU_OUT = 2  # 초
```

config로 빼되, **MVP는 고정값**으로.
복잡한 Timeout 파생은 V2에서.

---

### [38] ⚖️ 심판

τ 고정값 합의: **τ_in=4초, τ_out=2초**.

다음: **κ_floor와 k_spr 초기값은?**

---

### [39] 📊 퀀트

max02 제안:
- κ_floor = 60~150 bps
- k_spr = 2~6

**보수적 시작점**으로:
- κ_floor = 100 bps
- k_spr = 4

이러면 spread가 25 bps일 때:
```
κ = max(100, 4 × 25) = 100 bps
```

spread가 50 bps일 때:
```
κ = max(100, 4 × 50) = 200 bps
```

---

### [40] 🎯 스캘퍼

개잡주는 스프레드가 **100~300 bps** 흔합니다.

그러면:
```
κ = max(100, 4 × 200) = 800 bps
```

이건 너무 크지 않나요?

Q_max = V × (B/κ)²에서 κ가 8배 커지면 Q_max는 **64배 줄어듭니다**.

---

### [41] 🏦 기관

그게 **의도된 동작**입니다.

스프레드가 넓다 = 유동성이 나쁘다 = 임팩트가 크다

**제곱으로 급감하는 게 맞습니다.**
개잡주에서 사이즈를 키우면 안 되니까요.

---

### [42] 📊 퀀트

수치 예시:

| spread (bps) | κ (bps) | Q_max 상대값 |
|--------------|---------|-------------|
| 25 | 100 | 1.00 |
| 50 | 200 | 0.25 |
| 100 | 400 | 0.0625 |
| 200 | 800 | 0.0156 |

스프레드 8배 → 사이즈 **64배 감소**.
이게 Square-root law의 본질입니다.

---

### [43] 🎯 스캘퍼

수학적으론 맞는데...

**현실에서 스프레드 200 bps 종목도 돈 법니다.**
사이즈가 64배 줄면 수익도 의미없어지는 거 아닌가요?

---

### [44] 🏦 기관

그래서 **절대값 하한**이 필요합니다:

```python
Q_min = 100  # 최소 100주
if Q_max < Q_min:
    Q_max = 0  # 아예 하지 마라
```

**너무 작은 사이즈는 수수료에도 안 되므로 봉쇄.**

---

### [45] 🔧 시스템

정리:

```python
Q_max = calculate_q_max(...)
if Q_max < Q_MIN_SHARES:
    Q_max = 0  # 봉쇄
if Q_max * price < NOTIONAL_MIN:
    Q_max = 0  # 달러 기준 최소 미달
```

constants:
- Q_MIN_SHARES = 100
- NOTIONAL_MIN = $500

---

### [46] ⚖️ 심판

최소 사이즈 게이트 합의.

**B_in_bps와 B_out_bps(노임팩트 예산)는요?**

---

### [47] 📊 퀀트

max02 제안:
- B_in = 8~15 bps
- B_out = 6~12 bps (청산이 더 빡빡)

**시작점**: B_in = 10 bps, B_out = 8 bps

---

### [48] 🎯 스캘퍼

10 bps면 **$10,000 진입에 $10 슬리피지 허용**이라는 건데,
개잡주에서는 좀 타이트합니다.

**B_in = 15 bps** 정도가 현실적입니다.

---

### [49] 🏦 기관

엣지(예상 수익)와 비교해야 합니다.

만약 예상 엣지가 50 bps라면:
- B_in + B_out = 10 + 8 = 18 bps
- 총 비용 비율 = 18/50 = 36%

**엣지의 30~50%를 비용으로 쓰면** 여전히 양의 EV입니다.

엣지가 20 bps밖에 안 되면?
- 18/20 = 90% → **트레이드하면 안 됨**

---

### [50] ⚖️ 심판

좋은 포인트입니다.

**엣지 대비 비용 비율 게이트**를 추가할까요?

```python
if (B_in + B_out + fees) > edge_bps * 0.5:
    Q_max = 0  # EV 음수, 봉쇄
```

---

### [51] 🔧 시스템

문제: **edge_bps를 실시간으로 어떻게 알죠?**

Rheograph 엔진에서 "예상 엣지"를 출력하는 모듈이 없습니다.

---

### [52] 🎯 스캘퍼

엣지는 **사후적으로만** 알 수 있어요.

그래서 저는 **경험적 기대 엣지**를 씁니다:
- 🟢 ABSORPTION + High Score: 30~50 bps
- 🟡 VACUUM: 15~25 bps
- 🔴 FATIGUE: 0 (진입 안 함)

---

### [53] 📊 퀀트

그러면 **상태별 최대 비용 예산**으로 바꿔서:

| 상태 | 예상 엣지 | 최대 비용 (50%) |
|------|----------|----------------|
| 🟢 High | 40 bps | 20 bps |
| 🟢 Normal | 25 bps | 12 bps |
| 🟡 | 15 bps | 7 bps |

B_in + B_out이 이걸 초과하면 봉쇄.

---

### [54] 🏦 기관

복잡해지고 있습니다.

**MVP는 단순하게** 가죠:
- B_in = 12 bps (고정)
- B_out = 10 bps (고정)
- 엣지 게이트는 V2에서

상태가 🔴면 이미 Q_max = 0이니까.

---

### [55] ⚖️ 심판

MVP 단순화 동의합니다.

**spread_hard_max 값은요?**

---

### [56] 🎯 스캘퍼

경험상:
- 150 bps 넘으면 **매우 위험**
- 300 bps 넘으면 **절대 진입 금지**

**spread_hard_max = 200 bps**가 적당합니다.

---

### [57] 🏦 기관

동의합니다.

추가로 **변동성 연동**도 고려할 수 있지만, MVP는 고정값이 낫습니다.

---

### [58] 🔧 시스템

config:
```python
SPREAD_HARD_MAX_BPS = 200
L_MIN_DOLLAR_PER_SEC = 100  # $100/s 이하면 봉쇄
```

L_MIN은 "최소 1분에 $6,000 체결"을 의미합니다.
이것보다 적으면 진입해도 나올 수가 없습니다.

---

### [59] ⚖️ 심판

훌륭합니다. **거의 완성**됐네요.

마지막: **panic_discount 초기값?**

---

### [60] 🎯 스캘퍼

**0.4**로 시작합시다.

- 붕괴 시 유동성 60% 증발 가정
- 보수적이지만 현실적

---

### [61] 📊 퀀트

동의합니다.

캘리브레이션으로 조정:
```
panic_discount_obs = actual_exit_volume / expected_volume
```

---

### [62] 🏦 기관

0.4 동의.

추가로 **ToD에도 반영**:
- 데드존: panic_discount × 0.5 = 0.2
- 오프닝: panic_discount × 1.2 = 0.48

---

### [63] ⚖️ 심판

panic_discount = 0.4 합의.

---

## 최종 합의: MVP 사이징 로직

### 파라미터 (config)

```python
# 시간창 (초)
TAU_IN = 4
TAU_OUT = 2

# 노임팩트 예산 (bps)
B_IN_BPS = 12
B_OUT_BPS = 10

# 마찰 계수
KAPPA_FLOOR_BPS = 100
K_SPR = 4

# 패닉 할인
PANIC_DISCOUNT = 0.4

# 하드 게이트
SPREAD_HARD_MAX_BPS = 200
L_MIN_DOLLAR_PER_SEC = 100
Q_MIN_SHARES = 100
NOTIONAL_MIN = 500

# Float 캡
PHI = 0.002  # 0.2%

# 시간대 배수
TOD_MULT = {
    "PRE": 0.3, "OPN": 1.3, "MID1": 1.0,
    "DEAD": 0.5, "MID2": 0.8, "CLO": 1.2, "AH": 0.2
}
```

### 알고리즘

```python
def calculate_max_size(bid, ask, mid, last_price, last_size, dt, L_prev, Float, tod):
    # 1. 스프레드 계산
    spread_bps = (ask - bid) / mid * 10000
    
    # 2. L 업데이트 (EMA, half-life 5초)
    trade_notional = last_price * last_size
    rate = trade_notional / dt
    alpha = 1 - exp(-dt / 5)
    L = alpha * rate + (1 - alpha) * L_prev
    
    # 3. 하드 게이트
    if spread_bps > SPREAD_HARD_MAX_BPS:
        return 0, L
    if L < L_MIN_DOLLAR_PER_SEC:
        return 0, L
    
    # 4. 마찰 계수
    kappa = max(KAPPA_FLOOR_BPS, K_SPR * spread_bps)
    
    # 5. 시간대 배수
    tod_mult = TOD_MULT.get(tod, 1.0)
    
    # 6. 거래량 추정
    V_in = L * TAU_IN * tod_mult
    V_out = L * TAU_OUT * PANIC_DISCOUNT * tod_mult
    
    # 7. 사이즈 계산
    Q_in = V_in * (B_IN_BPS / kappa) ** 2
    Q_out = V_out * (B_OUT_BPS / kappa) ** 2
    
    # 8. Float 캡
    Q_float_cap = PHI * Float * last_price  # 달러로 변환
    
    # 9. 최종
    Q_max_notional = min(Q_in, Q_out, Q_float_cap)
    Q_max_shares = Q_max_notional / last_price
    
    # 10. 최소 사이즈 게이트
    if Q_max_shares < Q_MIN_SHARES or Q_max_notional < NOTIONAL_MIN:
        return 0, L
    
    return int(Q_max_shares), L
```

---

### [64] 🎯 스캘퍼

**완벽합니다.** 실전에 바로 써도 될 것 같아요.

---

### [65] 📊 퀀트

수학적으로 **일관성 있고 보수적**입니다.
캘리브레이션 로그만 잘 쌓으면 지속적으로 개선됩니다.

---

### [66] 🏦 기관

기관 관점에서도 **리스크 관리가 충분**합니다.
Float 캡과 panic_discount가 최악의 시나리오를 막아줍니다.

---

### [67] 🔧 시스템

**구현 가능합니다.** 
연산량은 틱당 수십 마이크로초 이내로 예상됩니다.

---

### [68] ⚖️ 심판

**합의 완료.**

이 로직을 **Rheograph 엔진의 SizingModule**로 구현합니다.

---

## 부록: 캘리브레이션 로그 스키마

```python
sizing_log = {
    "timestamp": datetime,
    "ticker": str,
    "entry": {
        "spread_bps": float,
        "L": float,
        "kappa": float,
        "Q_max": int,
        "Q_actual": int,
        "fill_time_sec": float,
        "slippage_bps": float,
    },
    "exit": {
        "trigger": str,  # "profit" | "stop" | "panic"
        "spread_bps": float,
        "L": float,
        "Q_actual": int,
        "fill_time_sec": float,
        "slippage_bps": float,
    },
    "state": {
        "macro": str,  # 🟢/🟡/🔴
        "micro": str,  # ABSORPTION/VACUUM/...
        "tod": str,    # OPN/DEAD/...
    }
}
```

**주간 리뷰**에서:
1. `slippage_bps / sqrt(Q/V)` 분포 확인
2. 70~90 퍼센타일로 κ 업데이트
3. `panic_discount` 실제 exit 데이터로 보정

---

## 추가 토론: 사이징 계산 시점

### [69] ⚖️ 심판

잠깐요. 중요한 이슈가 빠졌습니다.

**사이징을 "언제" 계산하는가?**

1. **진입 시 1회 계산 후 고정**
2. **포지션 보유 중 계속 동적 재계산**

어떤 방식이 맞나요?

---

### [70] 🎯 스캘퍼

**진입 시 1회 계산 후 고정**이 맞습니다.

이유:
- 진입할 때 계산한 사이즈로 들어감
- 들어간 후에 "아, 지금 유동성이 더 좋아졌네" 하고 추가매수하면?
- **이미 내가 시장에 있으니까 상황이 다름**

동적으로 사이즈 늘리면:
- 계획 없는 추가매수가 됨
- 오버트레이딩 위험
- 붕괴 시 더 큰 손실

---

### [71] 📊 퀀트

수학적으로도 문제가 있습니다.

Q_max 공식은 **"지금 빈손으로 들어간다면"**을 가정합니다:

```
Q_max = V × (B/κ)²
```

하지만 이미 포지션이 있으면?

```
Q_remaining = Q_max - Q_current
```

이걸 실시간으로 계산하면:
- V가 올라감 → Q_max 증가 → 추가매수 가능!
- 근데 이건 **원래 계획에 없던 트레이드**

---

### [72] 🏦 기관

기관에서는 **Order Slice**라는 개념을 씁니다.

- 전체 주문 = 100,000주
- 한 번에 전부 넣지 않고 10,000주씩 10번 나눠서 실행
- 각 슬라이스마다 V를 확인하고 **속도 조절**

하지만 **전체 수량 자체는 처음에 결정**합니다.

즉:
- 사이즈 결정: 진입 신호 시 **1회**
- 실행 방식: 슬라이스로 나눠서 **점진적**

---

### [73] 🔧 시스템

구현 관점에서:

**동적 사이징 문제점:**
1. 상태 관리 복잡 (현재 포지션 + 최대 사이즈 + 남은 여유분)
2. 레이스 컨디션 위험 (동시에 여러 신호 발생)
3. 로그 추적 어려움 (왜 이 수량을 샀는지 불명확)

**고정 사이징 장점:**
1. 진입 시 Q_max 계산 → 저장
2. 추가매수 신호 시 별도로 다시 계산
3. 각 계산이 독립적 → 디버깅 쉬움

---

### [74] 🎯 스캘퍼

추가매수(Add-on)에 대해서도 명확히 해야 합니다.

**추가매수 = 새로운 진입 결정**입니다.

- 첫 진입: Q1 = calculate_max_size() → 100주
- 5분 후 추가매수 신호 발생
- 추가매수: Q2 = calculate_max_size() → 80주 (조건이 바뀜)
- 총 포지션 = 100 + 80 = 180주

이건 "동적 사이징"이 아니라 **"2회의 독립적 사이징"**입니다.

---

### [75] 📊 퀀트

**총 포지션 제한**도 필요합니다.

추가매수를 무한히 하면 플로트 캡을 넘을 수 있으니:

```python
Q2 = min(
    calculate_max_size(),
    Q_float_cap - Q_current_position
)
```

즉, 추가매수 시에도:
- 새로 Q_max 계산
- 현재 포지션과 합쳐서 플로트 캡 초과 안 되게 조정

---

### [76] 🏦 기관

우리 용어로는:

- **Initial Sizing**: 첫 진입 시 사이즈 결정
- **Add-on Sizing**: 추가매수 시 별도 사이즈 결정
- **Total Exposure Cap**: 총 포지션 상한

세 가지가 분리되어야 합니다.

---

### [77] 🔧 시스템

구현 제안:

```python
class Position:
    def __init__(self, ticker):
        self.ticker = ticker
        self.entries = []  # [(timestamp, shares, entry_price, sizing_context)]
        
    def add_entry(self, shares, price, context):
        """새 진입 또는 추가매수 기록"""
        self.entries.append((now(), shares, price, context))
        
    def total_shares(self):
        return sum(e[1] for e in self.entries)

def on_entry_signal(ticker, Float):
    pos = get_or_create_position(ticker)
    
    # 1. 현재 조건에서 Q_max 계산
    Q_max, L = calculate_max_size(...)
    
    # 2. 총 포지션 제한 적용
    current = pos.total_shares() * price
    remaining_cap = PHI * Float * price - current
    Q_allowed = min(Q_max, remaining_cap)
    
    # 3. 이 진입 건에 대한 사이즈 확정 (이후 변경 없음)
    if Q_allowed > NOTIONAL_MIN:
        execute_entry(Q_allowed)
        pos.add_entry(Q_allowed / price, price, {"L": L, "kappa": kappa, ...})
```

---

### [78] 🎯 스캘퍼

**리스크 관점에서 추가:**

진입 후 사이즈를 **줄이는** 건 괜찮습니다.
- 손절 = 전량 청산
- 부분 익절 = 일부 청산

하지만 **늘리는** 건 별도 결정이어야 합니다.
- 불타기 = 새로운 진입 신호가 있어야 함
- 충동적 추가매수 방지

---

### [79] ⚖️ 심판

정리합니다.

**사이징 계산 시점 원칙:**

| 상황 | 사이징 계산 |
|------|------------|
| 첫 진입 신호 | calculate_max_size() → Q1 확정 |
| 포지션 보유 중 | 재계산 안 함 (Q1 유지) |
| 추가매수 신호 | calculate_max_size() → Q2 별도 계산 |
| 청산 | 사이징 무관 (보유분 전량/부분) |

**총 포지션 제한:**
```
Q_total = Q1 + Q2 + ... ≤ Q_float_cap
```

동의하시나요?

---

### [80] 🎯 스캘퍼

동의합니다.

---

### [81] 📊 퀀트

동의합니다. 수학적으로도 깔끔합니다.

---

### [82] 🏦 기관

동의합니다. 기관 실무와 일치합니다.

---

### [83] 🔧 시스템

구현 가능합니다. Position 클래스에 반영하겠습니다.

---

### [84] ⚖️ 심판

**추가 합의 완료.**

이 원칙을 **SizingModule 명세에 추가**합니다:

```python
# SizingModule 동작 원칙
#
# 1. calculate_max_size()는 "진입 신호 발생 시"에만 호출
# 2. 결과값은 해당 진입 건에 대해 고정 (이후 재계산 없음)
# 3. 추가매수는 별도 신호 → 별도 calculate_max_size() 호출
# 4. 총 포지션은 Q_float_cap을 초과할 수 없음
# 5. 청산 사이즈는 SizingModule이 결정하지 않음 (ExitModule 담당)
```

---

*확장 토론 종료: 2026-01-14*

---

## 추가 토론 2: 정기적 사이징 재계산과 포지션 자동 조정

### [85] ⚖️ 심판

새로운 이슈가 제기되었습니다.

**"포지션 보유 중에 시장 상황이 변하면 어떻게 하나요?"**

예를 들어:
- 진입 시 Q_max = 1000주로 계산, 800주 매수함
- 30분 후 유동성 급감 → 현재 Q_max = 300주로 떨어짐
- 내 800주 포지션이 현재 Q_max를 **초과**함

이 경우:
1. **그냥 둔다**: 원래 계획대로 진행
2. **자동 정리**: 초과분 500주를 즉시 매도
3. **경고만**: 알림 후 수동 결정

어떻게 해야 할까요?

---

### [86] 🎯 스캘퍼

**절대로 자동 정리하면 안 됩니다.**

이유:
- 유동성이 떨어진 상황에서 강제 매도? → **슬리피지 폭탄**
- 일시적 유동성 감소일 수 있음 (점심 시간대)
- 내 청산 주문이 가격을 더 밀어서 손실 확대

자동 매도는 **최악의 타이밍에 손절**하는 결과가 됩니다.

---

### [87] 📊 퀀트

수학적으로도 맞지 않습니다.

Q_max는 **"지금 빈손으로 들어간다면"** 의 최대값입니다.

이미 포지션이 있는 상태에서 Q_max가 떨어지면:
- 현재 보유 수량이 위험하다는 뜻이긴 함
- 하지만 즉시 청산하면 그 "위험"을 **실현**시키는 것

오히려 **청산 타이밍을 신중히** 잡아야 합니다.

---

### [88] 🏦 기관

기관에서도 **자동 강제 청산은 금지**입니다.

우리 룰:
- 리스크 한도 초과 시 **경고 발생**
- 트레이더가 직접 판단 후 청산
- 자동 청산은 **마진콜/청산가격 도달** 같은 극단 상황에만

왜냐면:
- 시장이 회복될 수 있음
- 강제 청산 자체가 추가 손실 유발
- 알고리즘이 판단을 대신하면 안 됨

---

### [89] 🔧 시스템

그러면 **정기적 재계산은 할 필요가 없다**는 건가요?

아니면 재계산은 하되 **청산 트리거로 쓰지 않는다**?

---

### [90] 🎯 스캘퍼

**모니터링 용도로만** 재계산합니다.

예:
- 매분 Q_max 재계산
- 현재 포지션이 Q_max의 150% 초과? → 대시보드에 **⚠️ 경고 표시**
- 200% 초과? → **🔴 위험** 표시
- 실제 청산은 내가 결정

---

### [91] 📊 퀀트

**위험 레벨 정의**:

| 비율 (보유/Q_max) | 레벨 | 표시 |
|-------------------|------|------|
| < 100% | 정상 | 🟢 |
| 100% ~ 150% | 주의 | 🟡 |
| 150% ~ 200% | 경고 | 🟠 |
| > 200% | 위험 | 🔴 |

> 이건 **정보 제공**이지, **자동 조치**가 아님

---

### [92] 🏦 기관

반대 상황도 있습니다.

- 진입 시 Q_max = 500주, 400주 매수
- 30분 후 유동성 증가 → Q_max = 1000주
- **100주 여유분이 더 생김**

이 경우 **자동 추가매수**를 할까요?

---

### [93] 🎯 스캘퍼

**절대 안 됩니다.**

추가매수는 **새로운 진입 결정**입니다:
- 새로운 진입 신호가 있어야 함
- 유동성이 좋아졌다고 자동으로 사이즈 늘리면?
- 그건 계획에 없는 **충동 매수**

---

### [94] 📊 퀀트

동의합니다.

**"Q_max 여유분"은 추가매수 "가능성"일 뿐**:
- 추가매수 신호 발생 시 → 그 시점에 Q_max 재계산
- 이미 여유가 있으면 추가매수 실행
- 여유가 없으면 추가매수 봉쇄

자동 추가매수 로직은 **없습니다**.

---

### [95] 🔧 시스템

정리하면:

**정기 재계산 용도:**
1. **모니터링 전용**: 현재 리스크 레벨 표시
2. **추가매수 가능 여부 판단**: 추가매수 신호 발생 시 참조
3. **자동 조치 없음**: 청산도, 추가매수도 자동화 안 함

---

### [96] ⚖️ 심판

그러면 **SizingMonitor**라는 별도 모듈이 필요합니다:

```python
class SizingMonitor:
    """포지션 보유 중 리스크 모니터링 (매분 호출)"""
    
    def check_risk_level(self, position, market_data) -> RiskLevel:
        # 현재 조건으로 Q_max 재계산
        current_q_max, _ = calculate_max_size(...)
        
        ratio = position.total_shares() / current_q_max
        
        if ratio > 2.0:
            return RiskLevel.DANGER
        elif ratio > 1.5:
            return RiskLevel.WARNING
        elif ratio > 1.0:
            return RiskLevel.CAUTION
        else:
            return RiskLevel.NORMAL
```

---

### [97] 🎯 스캘퍼

맞습니다.

**SizingModule** ≠ **SizingMonitor**:

| 모듈 | 역할 | 호출 시점 | 출력 |
|------|------|----------|------|
| SizingModule | 사이즈 결정 | 진입/추가매수 신호 시 | Q_max (주수) |
| SizingMonitor | 리스크 모니터링 | 매분 또는 이벤트 시 | RiskLevel (상태) |

---

### [98] 🏦 기관

**SizingMonitor 추가 기능**:

1. **Dry-run 모드**: "지금 진입하면 Q_max는?" 계산 (실제 진입 안 함)
2. **What-if 분석**: "스프레드가 50 bps로 변하면?" 시뮬레이션
3. **이력 로깅**: 리스크 레벨 변화 기록 (분석용)

---

### [99] 📊 퀀트

모니터 호출 주기:

| 상황 | 주기 |
|------|------|
| 정상 (🟢) | 1분 |
| 주의 (🟡) | 30초 |
| 경고 (🟠) | 10초 |
| 위험 (🔴) | 5초 |

리스크가 높아지면 **더 자주 체크**하되, 자동 조치는 없음.

---

### [100] ⚖️ 심판

**최종 합의:**

1. **SizingModule**: 진입/추가매수 시 Q_max 결정 (기존)
2. **SizingMonitor**: 보유 중 리스크 레벨 모니터링 (신규)
3. **자동 청산**: 없음 (경고만)
4. **자동 추가매수**: 없음 (신호 필요)

동의하시나요?

---

### [101] 🎯 스캘퍼

동의합니다.

---

### [102] 📊 퀀트

동의합니다.

---

### [103] 🏦 기관

동의합니다.

---

### [104] 🔧 시스템

구현하겠습니다. SizingMonitor를 별도 클래스로 추가합니다.

---

### [105] ⚖️ 심판

**추가 합의 2 완료.**

이 원칙을 **MaxCapSizingModule 명세에 추가**합니다:

```python
# 정기 모니터링 원칙
#
# 1. SizingMonitor는 SizingModule과 별도 모듈
# 2. 포지션 보유 중 Q_max를 정기적으로 재계산하여 리스크 레벨 표시
# 3. 리스크 레벨: NORMAL / CAUTION / WARNING / DANGER
# 4. 자동 청산: 없음 (경고만 발생)
# 5. 자동 추가매수: 없음 (별도 신호 필요)
# 6. 모니터링 주기: 리스크 레벨에 따라 5초~1분
```

---

*확장 토론 2 종료: 2026-01-14*

---

## 추가 토론 3: max02 vs maximum_per_trade01 비교 분석

### [106] ⚖️ 심판

max03 문서에서 두 접근법을 정리했습니다. 핵심 차이를 비교해봅시다.

**max02**: 미니멀 접근
- 상태변수 1개 (L)
- Square-root law 기반
- 스프레드로 κ 근사

**maximum_per_trade01**: 구조적 접근
- 상태머신 (Micro/Macro/Rotation)
- 참여율(π) 기반
- 다층 게이트 시스템

**질문**: 어느 쪽이 더 좋은가? 각각에서 차용할 점은?

---

### [107] 🎯 스캘퍼

둘 다 **같은 목표**를 다르게 표현한 겁니다.

| 관점 | max02 | maximum_per_trade01 |
|------|-------|---------------------|
| 철학 | 핵심만 | 구조적 |
| 구현 | 쉬움 | 복잡 |
| 디버깅 | 쉬움 | 어려움 |
| 정밀도 | 70~80% | 85~90% |

저는 **max02로 시작**하는 게 맞다고 봅니다.

---

### [108] 📊 퀀트

수학적으로 보면:

**max02의 강점:**
```
Q_max = V × (B/κ)²
```
- 단일 공식
- κ만 조정하면 됨
- 검증 쉬움

**maximum_per_trade01의 강점:**
```
π = f(상태, 시간대, 경보, 스프레드, ...)
Q_max = π × V × Δt
```
- 상태별 세밀한 조정
- 정책(Policy) 표현에 유리
- 확장성

---

### [109] 🏦 기관

실무에서는 **hybrid**가 제일 좋습니다.

**max02에서 차용할 것:**
1. L(유동성 속도 EMA) - 단일 상태변수, 연산 최소
2. κ 근사 공식 - 스프레드 기반
3. Square-root law 역산 - 수학적 근거

**maximum_per_trade01에서 차용할 것:**
1. 다층 캡 구조 - min(Q_in, Q_out, Q_float_cap, ...)
2. Float cap - 마이크로캡 필수
3. Catalyst unknown 봉쇄 - 원인불명 급등 대응
4. 상태(🟢🟡🔴) 게이트 - UI/로깅에 필요

---

### [110] 🔧 시스템

정리하면 **우리 최종 설계**는 이미 hybrid입니다:

```python
# max02에서 차용
L = EMA(trade_rate)                    # 단일 상태변수
kappa = max(floor, k × spread)         # 스프레드 근사
Q = V × (B/kappa)²                     # Square-root 역산

# maximum_per_trade01에서 차용
Q_max = min(Q_in, Q_out, Q_float_cap)  # 다층 캡
spread_gate, L_gate                     # 하드 게이트
ToD_mult                                # 시간대 배수
```

---

### [111] 🎯 스캘퍼

빠진 게 있습니다.

**maximum_per_trade01의 "Catalyst unknown" 봉쇄**:
- 원인불명 급등 → Q_max × 0.3 또는 Block

이거 넣어야 하나요?

---

### [112] 📊 퀀트

**MVP에서는 생략**해도 됩니다.

이유:
- "원인불명" 판정 자체가 복잡함
- 현재 Rheograph에 catalyst 분류 모듈 없음
- 스프레드/유동성 게이트로 어느 정도 커버됨

**V2에서 추가** 고려:
- ScoreModule에서 catalyst 점수 출력
- catalyst < threshold → Q_max × 0.3

---

### [113] 🏦 기관

**maximum_per_trade01의 🟡 Warning → Q × 0.5**도 논의해야 합니다.

현재 우리 설계:
- 🔴 → Q = 0 (하드 게이트)
- 🟡 → ? (없음)

제안:
- 🟡 경고 상태에서는 Q_max × 0.5 적용

---

### [114] 🎯 스캘퍼

**🟡 상태 자체가 MVP에 없습니다.**

현재:
- spread > max → 0 (봉쇄)
- L < min → 0 (봉쇄)
- 그 외 → 정상 계산

**"중간 상태"가 없어서** 0.5 배수를 적용할 수가 없습니다.

---

### [115] 🔧 시스템

그러면 **soft gate** 개념을 추가할 수 있습니다:

```python
# 하드 게이트 (현재)
if spread > HARD_MAX:
    return 0

# 소프트 게이트 (신규)
if spread > SOFT_MAX:
    Q_max *= 0.5  # 50% 감소
```

---

### [116] 📊 퀀트

**soft gate 파라미터**:

| 이름 | 값 | 설명 |
|------|-----|------|
| `SPREAD_SOFT_MAX_BPS` | 100 | 이 이상이면 Q × 0.5 |
| `SPREAD_HARD_MAX_BPS` | 200 | 이 이상이면 Q = 0 |
| `L_SOFT_MIN` | 500 | 이 이하면 Q × 0.5 |
| `L_HARD_MIN` | 100 | 이 이하면 Q = 0 |

이러면 **점진적 축소**가 가능합니다.

---

### [117] ⚖️ 심판

soft gate 추가 여부를 결정합시다.

**장점:**
- 점진적 리스크 관리
- 완전 봉쇄 전 경고 역할

**단점:**
- 파라미터 2배로 증가
- 튜닝 복잡도 증가

MVP에 넣을까요?

---

### [118] 🎯 스캘퍼

**MVP는 simple하게** 가죠.

하드 게이트만 쓰고, soft gate는 **SizingMonitor의 🟡 경고**로 대체합니다.

- SizingModule: 하드 게이트만 (0 or 계산값)
- SizingMonitor: soft 임계값에서 🟡 경고 표시

역할 분리!

---

### [119] 📊 퀀트

동의합니다.

**복잡도 분산:**
- SizingModule = 결정 (simple, binary)
- SizingMonitor = 경고 (nuanced, multi-level)

---

### [120] 🏦 기관

동의합니다.

실제로 우리도 **실행 모듈과 모니터링 모듈을 분리**합니다.

---

### [121] 🔧 시스템

정리:

| soft gate | SizingModule | SizingMonitor |
|-----------|--------------|---------------|
| spread 100 bps | - | 🟡 표시 |
| spread 200 bps | Q=0 | 🔴 표시 |
| L 500 $/s | - | 🟡 표시 |
| L 100 $/s | Q=0 | 🔴 표시 |

---

### [122] ⚖️ 심판

**최종 합의:**

**max02에서 채택:**
1. L (단일 상태변수, EMA)
2. κ = max(floor, k × spread)
3. Q = V × (B/κ)²

**maximum_per_trade01에서 채택:**
1. min(Q_in, Q_out, Q_float_cap) 구조
2. Float cap (φ × Float)
3. 시간대 배수 (ToD_mult)
4. 상태 게이트 컨셉 → SizingMonitor로 이관

**MVP에서 제외 (V2 고려):**
1. Catalyst unknown 봉쇄
2. Soft gate (SizingMonitor로 대체)
3. 🟡 상태 → Q × 0.5

동의하시나요?

---

### [123] 🎯 스캘퍼

동의합니다.

---

### [124] 📊 퀀트

동의합니다.

---

### [125] 🏦 기관

동의합니다.

---

### [126] 🔧 시스템

MaxCapSizingModule 명세에 반영하겠습니다.

---

### [127] ⚖️ 심판

**추가 합의 3 완료.**

```python
# 최종 설계 원칙 (hybrid)
#
# === max02 기반 ===
# - L: EMA($/s) 단일 상태변수
# - κ: max(100, 4 × spread)
# - Q: V × (B/κ)² (Square-root 역산)
#
# === maximum_per_trade01 기반 ===
# - Q_max = min(Q_in, Q_out, Q_float_cap)
# - Float cap: 0.2% × Float
# - ToD_mult: 시간대 배수
# - 상태 표시: SizingMonitor에서 🟢🟡🟠🔴
#
# === V2 예정 ===
# - Catalyst unknown → Q × 0.3
# - Soft gate → 점진적 축소
```

---

*확장 토론 3 종료: 2026-01-14*
