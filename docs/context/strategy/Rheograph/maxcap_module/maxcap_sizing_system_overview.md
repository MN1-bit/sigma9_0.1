# MaxCap Sizing System 종합 오버뷰

> **버전**: v1.0
> **작성일**: 2026-01-14
> **기반**: `sizing_logic_discussion.md` 127턴 토론 최종 합의

---

## 1. 설계 철학

### 1.1 핵심 원칙: "Exit-First, No-Impact"

이 시스템의 존재 이유는 단 하나입니다:

> **"내가 원할 때 나갈 수 있는 만큼만 들어간다"**

아무리 좋은 기회라도:
- 나갈 수 없으면 의미 없음
- 나갈 때 가격을 밀면 수익이 사라짐

따라서 **청산 가능 물량이 진입 물량의 상한**입니다.

### 1.2 No-Impact의 정의

"가격에 영향을 주지 않는다"는 구체적으로:

1. **슬리피지 예산 내 체결**: 진입 시 12 bps, 청산 시 10 bps 이하
2. **시장 참여율 제한**: 전체 거래량의 일정 비율 이하
3. **플로트 점유 제한**: 유통 주식의 0.2% 이하

### 1.3 Hybrid 접근법

두 가지 이론을 결합했습니다:

| 출처 | 핵심 아이디어 | 채택 요소 |
|------|-------------|----------|
| **max02** | 최소 연산, 수학적 순수성 | L(EMA), κ 근사, Square-root 역산 |
| **maximum_per_trade01** | 구조적, 정책 표현 | 다층 캡, Float cap, 시간대 배수 |

---

## 2. 시스템 구성

### 2.1 모듈 구조

```
┌─────────────────────────────────────────────────┐
│                  Rheograph Engine               │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────┐         ┌─────────────────┐   │
│  │ SizingModule│ ◄─────► │  SizingMonitor  │   │
│  │ (결정)      │         │  (모니터링)      │   │
│  └─────────────┘         └─────────────────┘   │
│         │                        │             │
│         ▼                        ▼             │
│  ┌─────────────┐         ┌─────────────────┐   │
│  │ Position    │         │  Dashboard UI   │   │
│  │ Manager     │         │  (리스크 표시)   │   │
│  └─────────────┘         └─────────────────┘   │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 2.2 역할 분리

| 모듈 | 역할 | 호출 시점 | 출력 |
|------|------|----------|------|
| **SizingModule** | Q_max 결정 | 진입/추가매수 신호 시 | 주수 (정수) |
| **SizingMonitor** | 리스크 모니터링 | 매분~5초 (리스크 레벨별) | 🟢🟡🟠🔴 |
| **PositionManager** | 포지션 기록 | 체결 시 | Entry 객체 |

---

## 3. 상세 로직 (자연어 설명)

### 3.1 전체 흐름

1. **진입 신호 발생** → SizingModule 호출
2. **시장 데이터 수집**: bid, ask, 마지막 체결가/수량
3. **유동성 속도 계산**: 최근 체결 데이터로 "1초에 얼마나 거래되나" 추정
4. **위험 게이트 확인**: 스프레드 너무 넓거나 거래량 너무 적으면 즉시 거래 금지
5. **마찰 계수 계산**: 스프레드 기반으로 "이 종목이 얼마나 움직이기 쉬운가" 추정
6. **진입/청산 용량 계산**: 각각 허용 슬리피지 내에서 최대 얼마나 거래 가능한지
7. **여러 상한 중 최소 선택**: 가장 빡빡한 조건이 최종 상한
8. **최소 크기 확인**: 너무 작으면 수수료만 나가니까 거래 금지

### 3.2 핵심 계산 단계

#### 단계 1: 유동성 속도 (L)

```
새 체결이 오면:
  이 체결의 달러 금액 = 가격 × 수량
  이 체결의 속도 = 달러 금액 ÷ 경과 시간
  L = 이전 L와 새 속도의 가중 평균 (최근 것에 더 큰 가중치)
```

**의미**: "지금 이 종목이 1초에 평균 얼마나 거래되고 있는가"

**예시**: L = $50,000/초 → 1초에 5만 달러어치 거래됨

#### 단계 2: 마찰 계수 (κ)

```
κ = 최소값(100)과 (4 × 스프레드) 중 큰 값
```

**의미**: "이 종목에서 주문을 넣으면 가격이 얼마나 움직이는가"

**예시**: 
- 스프레드 25 bps → κ = max(100, 100) = 100
- 스프레드 50 bps → κ = max(100, 200) = 200

#### 단계 3: 예상 거래량 (V)

```
진입 거래량 = L × 4초 × 시간대 배수
청산 거래량 = L × 2초 × 0.4(패닉 할인) × 시간대 배수
```

**의미**: "4초/2초 동안 시장에서 거래될 예상 금액"

**청산이 더 적은 이유**: 급할 때는 시간도 짧고 유동성도 줄어듦

#### 단계 4: 최대 금액 (Q)

```
Q = V × (허용 슬리피지 ÷ 마찰)²
```

**의미**: "이 슬리피지 예산으로 이 시장에서 거래 가능한 최대 금액"

**제곱이 있는 이유**: 시장 임팩트는 제곱근 법칙을 따름

#### 단계 5: 최종 사이즈

```
최종 = min(진입 Q, 청산 Q, 플로트 Q, ...)
주수 = 최종 금액 ÷ 현재 가격
```

**의미**: 가장 빡빡한 조건이 최종 상한

---

## 4. 구동 방식

### 4.1 호출 규칙

| 이벤트 | 동작 |
|--------|------|
| 첫 진입 신호 | `calculate_max_size(current_position=0)` |
| 추가매수 신호 | `calculate_max_size(current_position=기존 보유분)` |
| 포지션 보유 중 | **재호출 안 함** (기존 Q 유지) |
| 청산 | SizingModule 호출 안 함 (ExitModule 담당) |

### 4.2 SizingMonitor 주기

| 리스크 레벨 | 주기 | 트리거 조건 |
|-------------|------|-------------|
| 🟢 정상 | 1분 | 포지션/Q_max < 100% |
| 🟡 주의 | 30초 | 100% < 비율 < 150% |
| 🟠 경고 | 10초 | 150% < 비율 < 200% |
| 🔴 위험 | 5초 | 비율 > 200% |

### 4.3 상태 관리

**SizingModule**: Stateless (상태 없음)
- L은 외부에서 관리, 호출 시 전달

**PositionManager**: Stateful (상태 있음)
- 각 진입 건의 {시간, 수량, 가격, sizing context} 저장

---

## 5. 파인튜닝 전략

### 5.1 캘리브레이션 대상

| 파라미터 | 초기값 | 조정 방법 |
|----------|--------|----------|
| κ_floor | 100 bps | 슬리피지 로그에서 80분위수로 상향 |
| k_spr | 4 | 스프레드 민감도 조정 |
| B_in | 12 bps | 실제 슬리피지 분포 기반 |
| B_out | 10 bps | 실제 슬리피지 분포 기반 |
| panic_discount | 0.4 | 실제 청산 시 유동성 감소율 관측 |

### 5.2 캘리브레이션 공식

**κ 업데이트 (주간):**
```
각 거래에서:
  κ_obs = 실제 슬리피지 ÷ √(체결금액 ÷ 거래량)

모든 거래의 κ_obs를 수집:
  κ_new = 80분위수(κ_obs 리스트)
```

**panic_discount 업데이트 (주간):**
```
청산 시:
  panic_obs = 실제 청산 거래량 ÷ 예상 거래량

panic_new = 30분위수(panic_obs 리스트)  # 보수적
```

### 5.3 A/B 테스트 전략

| 단계 | 기간 | 목표 |
|------|------|------|
| 1. Paper Trading | 2주 | 로직 검증, 버그 발견 |
| 2. 최소 자본 | 2주 | 실제 슬리피지 수집, κ 초기 튜닝 |
| 3. 점진적 확대 | 4주+ | 파라미터 안정화 |

---

## 6. 컴퓨팅 리소스 및 레이턴시 분석

### 6.1 연산량 분석

**SizingModule.calculate_max_size():**

| 연산 | 횟수 | 비용 |
|------|------|------|
| 나눗셈 | 3 | 3 × 20ns = 60ns |
| 곱셈 | 8 | 8 × 5ns = 40ns |
| 제곱 | 2 | 2 × 10ns = 20ns |
| exp() | 1 | 50ns |
| max/min | 4 | 4 × 2ns = 8ns |
| 조건 분기 | 4 | 4 × 1ns = 4ns |
| **총합** | | **~200ns** |

### 6.2 예상 레이턴시

| 환경 | 레이턴시 |
|------|----------|
| Python (순수) | 5~10 μs |
| Python + NumPy | 2~5 μs |
| Cython/Numba | 500ns~1μs |
| Rust/C++ | 100~300ns |

**결론**: Python으로도 **초당 100,000+ 호출** 가능. 병목이 아님.

### 6.3 메모리 사용

| 데이터 | 크기 |
|--------|------|
| L (상태변수) | 8 bytes per ticker |
| Config 파라미터 | ~200 bytes (고정) |
| Position 1건 | ~100 bytes |

**1000 종목 모니터링**: ~10 KB (무시 가능)

### 6.4 호출 빈도 추정

| 상황 | 빈도 |
|------|------|
| SizingModule (진입 시) | 1~10회/분 |
| SizingMonitor | 1~12회/분 (종목당) |

**100 종목 모니터링**: 최대 1,200회/분 = 20회/초 → **여유 있음**

---

## 7. 설정 파라미터 전체 목록

### 7.1 Core Parameters

```python
# 시간창 (초)
TAU_IN = 4                  # 진입 실행 시간
TAU_OUT = 2                 # 청산 실행 시간
EMA_HALF_LIFE = 5           # L 계산용 반감기

# 슬리피지 예산 (bps)
B_IN_BPS = 12               # 진입 허용 슬리피지
B_OUT_BPS = 10              # 청산 허용 슬리피지

# 마찰 계수
KAPPA_FLOOR_BPS = 100       # 마찰 최소값
K_SPR = 4                   # 스프레드 → κ 배수

# 패닉 할인
PANIC_DISCOUNT = 0.4        # 청산 시 유동성 감소율
```

### 7.2 Gate Parameters

```python
# 하드 게이트
SPREAD_HARD_MAX_BPS = 200   # 이상이면 Q=0
L_MIN_DOLLAR_PER_SEC = 100  # 이하면 Q=0
Q_MIN_SHARES = 100          # 최소 주문 주수
NOTIONAL_MIN = 500          # 최소 주문 금액 ($)

# Float 캡
PHI = 0.002                 # 0.2%
```

### 7.3 Time-of-Day Multipliers

```python
TOD_MULT = {
    "PRE":  0.3,  # 04:00-09:30 장전
    "OPN":  1.3,  # 09:30-10:00 개장
    "MID1": 1.0,  # 10:00-11:30 오전
    "DEAD": 0.5,  # 11:30-14:00 점심
    "MID2": 0.8,  # 14:00-15:30 오후
    "CLO":  1.2,  # 15:30-16:00 마감
    "AH":   0.2,  # 16:00-20:00 장후
}
```

### 7.4 Monitoring Thresholds

```python
# SizingMonitor 리스크 레벨
RISK_THRESHOLDS = {
    "NORMAL": 1.0,    # < 100%
    "CAUTION": 1.5,   # 100% ~ 150%
    "WARNING": 2.0,   # 150% ~ 200%
    "DANGER": float('inf')  # > 200%
}

# 모니터링 주기 (초)
MONITOR_INTERVALS = {
    "NORMAL": 60,
    "CAUTION": 30,
    "WARNING": 10,
    "DANGER": 5,
}
```

---

## 8. 사용자/개발자 가이드

### 8.1 사용자가 알아야 할 것

1. **Q_max = 0 표시 의미**: 현재 조건에서 진입 불가 (스프레드 과대 또는 유동성 부족)
2. **리스크 레벨 색상**: 🟢정상 → 🟡주의 → 🟠경고 → 🔴위험
3. **자동 청산 없음**: 리스크 레벨이 🔴여도 자동 매도 안 함 (사용자 결정)
4. **추가매수 시 재계산**: 조건이 바뀌면 추가매수 가능 수량도 바뀜

### 8.2 개발자가 알아야 할 것

1. **Stateless 설계**: SizingModule은 상태 없음, L은 외부에서 관리
2. **호출 시점 엄수**: 진입/추가매수 신호 시에만 호출, 보유 중 재호출 금지
3. **로깅 필수**: 캘리브레이션을 위해 모든 호출과 결과 기록
4. **테스트 케이스**: 봉쇄 케이스 (spread 과대, L 부족) 반드시 테스트

### 8.3 확장 시 주의점

**V2 예정 기능:**
- Catalyst unknown 봉쇄 → ScoreModule 연동 필요
- Soft gate → 파라미터 2배 증가, 튜닝 복잡도 ↑

---

## 9. 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| v1.0 | 2026-01-14 | 초기 버전 (127턴 토론 합의 기반) |

---

*문서 끝*
