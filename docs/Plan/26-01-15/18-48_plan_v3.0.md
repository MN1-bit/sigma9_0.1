네. “사람 직관” 빼고, **historical day gainers를 모아서 ‘급등 전조’를 딱 뽑아내는** 가장 **쉽고/정확하고/분명한** 프로세스를 **한 줄기 파이프라인**으로 정리해드리겠습니다. (핵심은 *전조를 정의하지 않고, 데이터가 전조를 뽑게* 만드는 겁니다.)

---

# 목표

**데이게이너(+75% 등)** 들을 모아 “급등 직전 구간”의 패턴을 **자동으로 추출**하고,
그 패턴이 **OOS(미래 기간)에서도 재현**되면 그것을 “전조”라고 선언한다.

---

# 전체 과정 (딱 10단계, 이것만 따라가면 ‘전조’가 나온다)

## 1) Day gainer 정의를 고정한다 (Outcome 고정)

* Universe: NASDAQ/NYSE/AMEX common stock (ETF/권리주/스플릿 이벤트 제외)
* Day gainer: **R_day ≥ +75%** (기준은 *당일 high vs 전일 close* 또는 *당일 close vs 전일 close* 중 하나로 고정)
* 기간: 최소 2~5년 (핫마켓/리스크오프 다 포함)

> 여기서부터 “정답”이 하나로 고정돼야 나중에 흔들리지 않습니다.

---

## 2) “급등 시작 시점”을 인간이 아니라 ‘규칙 1개’로만 정한다 (Anchor)

전조를 만들기 위해 “급등이 시작된 T0”는 **딱 1개 규칙**으로 정합니다.

추천(가장 안정적):

* **T0 = 당일 intraday high가 전일 close 대비 +X%를 처음 돌파한 시각**
  (X는 10% 또는 15%처럼 작게. *이건 전조가 아니라 ‘정렬 기준’*임)

왜 이게 중요한가?

* 모든 데이게이너를 “같은 사건을 기준으로 정렬”해서,
  **T0 이전 패턴의 공통점**을 찾을 수 있습니다.

---

## 3) 전조 탐색 구간을 고정한다 (Pre-window)

* 관측창: **[T0-30분, T0-5분]** (또는 15분~3분)
* 이유: 너무 멀면 잡음, 너무 가까우면 이미 시작

---

## 4) Negative를 “어려운 음성”으로만 만든다 (핵심)

이 단계가 결과의 80%입니다.

Negative(하드 네거티브) 구성:

* 같은 종목의 다른 날(같은 시간대) + “T0 같은 사건은 발생했지만 +75%까지 못 간 날”
* 또는 당일 +10~+30%까진 갔는데 +75% 못 간 종목

즉, 모델이 배우는 건
“급등 직전” vs “급등처럼 보이는데 결국 실패”
이 차이입니다.

---

## 5) 데이터는 “그 시점까지”로만 만든다 (누수 0)

각 샘플(윈도우)은 **T0 이전 데이터만** 포함:

* 초/틱(가능하면) 또는 1분봉
* 당일 high/low/close 같은 “하루 전체” 값은 금지
* 누적 거래대금도 “윈도우 끝 시점까지 누적”만 허용

---

## 6) 피처는 ‘사람이 이해 못 해도 되는 형태’로 만든다 (전조 발굴용)

여기서 “사람 직관 피처”로 시작하면 모순이 다시 생깁니다.
그래서 v0은 **형태(Shape) 피처**로 갑니다.

추천 최소 세트(모두 window 내에서 계산):

* **Return path**: r(t) 시계열을 일정 길이로 리샘플(예: 180초→60포인트)
* **Volume/Trade intensity path**: v(t), trades(t)
* **Volatility path**: |r(t)|, range(t)
* (있으면) **L2 shape**: spread(t), depth-imbalance(t)

이렇게 하면 “전조의 정의”를 사람이 하지 않고,
모델이 **패턴의 모양**을 직접 잡습니다.

---

## 7) 전조 후보를 “클러스터링”으로 뽑아낸다 (Discovery)

* Positive 샘플들의 시계열을 latent로 압축(오토인코더/contrastive)
* latent를 HDBSCAN/k-means로 클러스터링
* 각 클러스터 = “전조 패턴 후보”

이때 인간은 개입하지 않습니다.
그냥 “패턴 종류 A,B,C…”가 자동 생성됩니다.

---

## 8) 각 클러스터가 진짜 ‘전조’인지 검증한다 (Validation)

각 클러스터 c에 대해 OOS에서:

* P(DayGainer | c)
* 리드타임 분포(얼마나 빨리 잡힘)
* 알림 빈도(하루 몇 번 뜨는지)
* 실패 시 하방 위험(드로우다운)

**조건을 통과한 클러스터만** “전조”로 채택합니다.

---

## 9) 전조를 “한 문장”으로 번역한다 (사후 해석)

이제서야 사람이 이해할 수 있게 요약합니다.

예:

* 전조 #1: “체결강도는 일정 수준 이상인데 가격 반응이 비정상적으로 커지는 형태”
* 전조 #2: “변동성은 줄어드는데 거래강도는 증가하는 ‘압축-축적’ 형태”
* 전조 #3: “임팩트가 양(+)으로 고정되며 되밀림이 거의 없는 형태”

중요: 이 문장은 “정의”가 아니라 **발견된 클러스터의 설명**입니다.

---

## 10) 스캐너 구현은 “클러스터 멤버십 점수”로 한다 (Deployment)

실시간에서:

1. 최근 30분 데이터를 같은 방식으로 임베딩 z(t)
2. z(t)가 “전조 클러스터” 근처면 알림
3. 알림 예산(하루 N개), 종목 쿨다운 적용

이렇게 하면 스캐너가 내놓는 답은 딱 하나입니다:

> “지금 들어온 패턴이, 과거 데이게이너 직전 패턴 클러스터와 통계적으로 동일하다.”

이게 **가장 분명한 ‘전조’ 정의**입니다.

---

# 이 과정이 “쉽고 정확하고 분명”한 이유 (핵심 3개)

1. 전조를 사람의 직관으로 **정의하지 않는다** → 데이터가 전조를 만든다
2. Negative를 “급등처럼 보이는데 실패”로 잡아 **진짜 차이만 학습**한다
3. 전조는 “모델이 만든 패턴 클러스터”로 고정되므로 **스캐너 구현이 직결**된다

---

# 결과물(최종 산출) 형태

이 파이프라인을 끝내면 최종 답은 이렇게 나옵니다:

* 전조 패턴 5~20개(클러스터 ID)
* 각 전조의

  * OOS 성공률
  * 평균 리드타임
  * 하루 발생 빈도
  * 실패 시 손실분포
* 그리고 “스캐너 룰”은:

  * `if membership_score(cluster_k) > θ_k: alert`

---

원하시면 다음 메시지에서, 위 과정을 그대로 **문서(SSOT) 형태**로:

* 데이터 스키마(윈도우/이벤트/아웃컴/클러스터 테이블)
* 샘플링 레시피(positive/negative 생성 규칙)
* 평가 지표(알림 중심)
* 스캐너 동작 명세(쿨다운/예산/임계)
  까지 “그대로 구현 가능한” 설계 문서로 재작성해드리겠습니다.
